From ccf38fb93f9e9baaf40108e17d6c833d296d192b Mon Sep 17 00:00:00 2001
From: "D, Lakshmi Sowjanya" <lakshmi.sowjanya.d@intel.com>
Date: Fri, 6 Nov 2020 17:55:16 +0530
Subject: [PATCH 1/1] serial: 8250: PSE_DMA_Quirk_fix

Added Quirk API to fix the previous PSE DMA hack.

Signed-off-by: Kumar, Aman <aman.kumar@intel.com>
---
 drivers/tty/serial/8250/8250_dma.c | 87 +++++++++++++++++++-----------
 1 file changed, 55 insertions(+), 32 deletions(-)

diff --git a/drivers/tty/serial/8250/8250_dma.c b/drivers/tty/serial/8250/8250_dma.c
index de4562015ab9..0ee351fc1a1d 100644
--- a/drivers/tty/serial/8250/8250_dma.c
+++ b/drivers/tty/serial/8250/8250_dma.c
@@ -12,6 +12,20 @@
 
 #include "8250.h"
 
+static bool pse_dma_quirk;
+
+static void quirk_pse_dma(struct pci_dev *dev)
+{
+	pse_dma_quirk = true;
+}
+
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x4b96, quirk_pse_dma);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x4b97, quirk_pse_dma);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x4b98, quirk_pse_dma);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x4b99, quirk_pse_dma);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x4b9a, quirk_pse_dma);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x4b9b, quirk_pse_dma);
+
 static void __dma_tx_complete(void *param)
 {
 	struct uart_8250_port	*p = param;
@@ -20,9 +34,13 @@ static void __dma_tx_complete(void *param)
 	unsigned long	flags;
 	int		ret;
 
-	dma_sync_single_for_cpu(dma->txchan->device->dev, dma->tx_addr,
+	if (pse_dma_quirk) {
+		dma_sync_single_for_cpu(p->port.dev, dma->tx_addr,
+					UART_XMIT_SIZE, DMA_TO_DEVICE);
+	} else {
+		dma_sync_single_for_cpu(dma->txchan->device->dev, dma->tx_addr,
 				UART_XMIT_SIZE, DMA_TO_DEVICE);
-
+	}
 	spin_lock_irqsave(&p->port.lock, flags);
 
 	dma->tx_running = 0;
@@ -93,8 +111,13 @@ int serial8250_tx_dma(struct uart_8250_port *p)
 
 	dma->tx_cookie = dmaengine_submit(desc);
 
-	dma_sync_single_for_device(dma->txchan->device->dev, dma->tx_addr,
+	if (pse_dma_quirk) {
+		dma_sync_single_for_device(p->port.dev, dma->tx_addr,
 				   UART_XMIT_SIZE, DMA_TO_DEVICE);
+	} else {
+		dma_sync_single_for_device(dma->txchan->device->dev,
+				dma->tx_addr, UART_XMIT_SIZE, DMA_TO_DEVICE);
+	}
 
 	dma_async_issue_pending(dma->txchan);
 	if (dma->tx_err) {
@@ -144,22 +167,6 @@ void serial8250_rx_dma_flush(struct uart_8250_port *p)
 }
 EXPORT_SYMBOL_GPL(serial8250_rx_dma_flush);
 
-/* Hack for PSE UART */
-static int hack_for_ehl_pse_dma(struct device *dev)
-{
-	struct pci_dev *port_pci;
-
-	port_pci = to_pci_dev(dev);
-
-	if ((port_pci->vendor == PCI_VENDOR_ID_INTEL) &&
-		(port_pci->device == 0x4b96 || port_pci->device == 0x4b97 ||
-		 port_pci->device == 0x4b98 || port_pci->device == 0x4b99 ||
-		 port_pci->device == 0x4b9a || port_pci->device == 0x4b9b))
-		return 1;
-
-	return 0;
-}
-
 int serial8250_request_dma(struct uart_8250_port *p)
 {
 	struct uart_8250_dma	*dma = p->dma;
@@ -226,8 +233,7 @@ int serial8250_request_dma(struct uart_8250_port *p)
 	if (!dma->rx_size)
 		dma->rx_size = PAGE_SIZE;
 
-	/* Hack for PSE UART */
-	if (hack_for_ehl_pse_dma(p->port.dev)) {
+	if (pse_dma_quirk) {
 		dma->rx_buf = dma_alloc_coherent(p->port.dev, dma->rx_size,
 						&dma->rx_addr, GFP_KERNEL);
 	} else {
@@ -241,24 +247,30 @@ int serial8250_request_dma(struct uart_8250_port *p)
 	}
 
 	/* TX buffer */
-	/*Hack for PSE UART*/
-	if (hack_for_ehl_pse_dma(p->port.dev)) {
+	if (pse_dma_quirk) {
 		dma->tx_addr = dma_map_single(p->port.dev,
 						p->port.state->xmit.buf,
 						UART_XMIT_SIZE,
 						DMA_TO_DEVICE);
+		if (dma_mapping_error(p->port.dev, dma->tx_addr)) {
+			dma_free_coherent(p->port.dev, dma->rx_size,
+					dma->rx_buf, dma->rx_addr);
+		ret = -ENOMEM;
+		goto err;
+		}
 	} else {
 		dma->tx_addr = dma_map_single(dma->txchan->device->dev,
 						p->port.state->xmit.buf,
 						UART_XMIT_SIZE,
 						DMA_TO_DEVICE);
-	}
 
-	if (dma_mapping_error(dma->txchan->device->dev, dma->tx_addr)) {
-		dma_free_coherent(dma->rxchan->device->dev, dma->rx_size,
-				  dma->rx_buf, dma->rx_addr);
-		ret = -ENOMEM;
-		goto err;
+		if (dma_mapping_error(dma->txchan->device->dev, dma->tx_addr)) {
+			dma_free_coherent(dma->rxchan->device->dev,
+					dma->rx_size, dma->rx_buf,
+					dma->rx_addr);
+			ret = -ENOMEM;
+			goto err;
+		}
 	}
 
 	dev_dbg_ratelimited(p->port.dev, "got both dma channels\n");
@@ -281,15 +293,26 @@ void serial8250_release_dma(struct uart_8250_port *p)
 
 	/* Release RX resources */
 	dmaengine_terminate_sync(dma->rxchan);
-	dma_free_coherent(dma->rxchan->device->dev, dma->rx_size, dma->rx_buf,
-			  dma->rx_addr);
+
+	if (pse_dma_quirk) {
+		dma_free_coherent(p->port.dev, dma->rx_size,
+				dma->rx_buf, dma->rx_addr);
+	} else {
+		dma_free_coherent(dma->rxchan->device->dev, dma->rx_size,
+				dma->rx_buf, dma->rx_addr);
+	}
 	dma_release_channel(dma->rxchan);
 	dma->rxchan = NULL;
 
 	/* Release TX resources */
 	dmaengine_terminate_sync(dma->txchan);
-	dma_unmap_single(dma->txchan->device->dev, dma->tx_addr,
+	if (pse_dma_quirk) {
+		dma_unmap_single(p->port.dev, dma->tx_addr,
+				UART_XMIT_SIZE, DMA_TO_DEVICE);
+	} else {
+		dma_unmap_single(dma->txchan->device->dev, dma->tx_addr,
 			 UART_XMIT_SIZE, DMA_TO_DEVICE);
+	}
 	dma_release_channel(dma->txchan);
 	dma->txchan = NULL;
 	dma->tx_running = 0;
-- 
2.17.1

