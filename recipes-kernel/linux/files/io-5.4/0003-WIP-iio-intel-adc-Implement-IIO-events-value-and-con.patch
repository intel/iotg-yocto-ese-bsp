From 672d2ee75b776041df8f7710d58985712b5424e6 Mon Sep 17 00:00:00 2001
From: Raymond Tan <raymond.tan@intel.com>
Date: Tue, 23 Jun 2020 02:48:45 +0800
Subject: [PATCH 3/3] WIP - iio: intel-adc: Implement IIO events value and
 config callback

iio_event_spec is being registered to suppor RISING and FALLING,
however there's missing corresponding callback implementation for
read/write_event_value & read/write_event_config.

This will throw kernel dump stack due to NULL pointer deference from
IIO subsystem call when user accesses the syfs for these functions.

Signed-off-by: Raymond Tan <raymond.tan@intel.com>
---
 drivers/iio/adc/intel-adc.c | 100 +++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 94 insertions(+), 6 deletions(-)

diff --git a/drivers/iio/adc/intel-adc.c b/drivers/iio/adc/intel-adc.c
index 70ec063..da06ff5 100644
--- a/drivers/iio/adc/intel-adc.c
+++ b/drivers/iio/adc/intel-adc.c
@@ -67,6 +67,7 @@
 #define ADC_FIFO_DATA			0x0800
 
 #define ADC_BITS			14
+#define ADC_NUM_CNL			8
 
 /* ADC DMA Ctrl */
 #define ADC_DMA_CTRL_EN			BIT(0)
@@ -102,6 +103,15 @@
 #define ADC_CONFIG1_CNL_SEL(ch)		((ch) << 1)
 #define ADC_CONFIG1_DIFF_SE_SEL		BIT(0)
 
+/* ADC Threshold Register */
+#define ADC_DATA_THRESHOLD_HIGH_MASK	GENMASK(15, 0)
+#define ADC_DATA_THRESHOLD_LOW_MASK	GENMASK(31, 16)
+
+/* ADC Threshold Configuration */
+#define ADC_DATA_THRESHOLD_HIGH_EN	BIT(0)
+#define ADC_DATA_THRESHOLD_LOW_EN	BIT(8)
+#define ADC_DATA_THRESHOLD_DIS_MASK	GENMASK(7,0)
+
 /* ADC Interrupt Mask Register */
 #define ADC_INTR_LOOP_DONE_INTR		BIT(22)
 #define ADC_INTR_FIFO_EMPTY_INTR	BIT(21)
@@ -172,6 +182,8 @@ struct intel_adc {
 	struct completion completion;
 	void __iomem *regs;
 	u32 value;
+	u32 threshold[ADC_NUM_CNL];
+	u32 threshold_en[ADC_NUM_CNL];
 };
 
 static inline void intel_adc_writel(void __iomem *base, u32 offset, u32 value)
@@ -322,8 +334,88 @@ static int intel_adc_read_raw(struct iio_dev *iio,
 	return ret;
 }
 
+static int intel_adc_read_thresh(struct iio_dev *iio,
+	const struct iio_chan_spec *chan, enum iio_event_type type,
+	enum iio_event_direction dir, enum iio_event_info info, int *val,
+	int *val2)
+{
+	struct intel_adc *adc = iio_priv(iio);
+	if (dir == IIO_EV_DIR_FALLING)
+		*val = (adc->threshold[chan->channel] & ADC_DATA_THRESHOLD_LOW_MASK) >> 16;
+	else
+		*val = adc->threshold[chan->channel] & ADC_DATA_THRESHOLD_HIGH_MASK;
+	return IIO_VAL_INT;
+}
+
+static int intel_adc_write_thresh(struct iio_dev *iio,
+	const struct iio_chan_spec *chan, enum iio_event_type type,
+	enum iio_event_direction dir, enum iio_event_info info, int val,
+	int val2)
+{
+	struct intel_adc *adc = iio_priv(iio);
+
+	switch (dir) {
+	case IIO_EV_DIR_FALLING:
+		adc->threshold[chan->channel] &= ~(ADC_FIFO_DATA_SAMPLE_MASK << 16);
+		adc->threshold[chan->channel] |= ((val & ADC_FIFO_DATA_SAMPLE_MASK) << 16);
+		break;
+	case IIO_EV_DIR_RISING:
+		adc->threshold[chan->channel] &= ~(ADC_FIFO_DATA_SAMPLE_MASK);
+		adc->threshold[chan->channel] |= (val & ADC_FIFO_DATA_SAMPLE_MASK);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int intel_adc_write_event_config(struct iio_dev *iio,
+	const struct iio_chan_spec *chan, enum iio_event_type type,
+	enum iio_event_direction dir, int state)
+{
+	struct intel_adc *adc = iio_priv(iio);
+
+	if (dir == IIO_EV_DIR_FALLING) {
+		if (state == 0)
+			adc->threshold_en[chan->channel] &= ~(ADC_DATA_THRESHOLD_DIS_MASK << 8);
+		else {
+			adc->threshold_en[chan->channel] &= ~(ADC_DATA_THRESHOLD_DIS_MASK << 8);
+			adc->threshold_en[chan->channel] |= ADC_DATA_THRESHOLD_LOW_EN;
+		}
+	} else {
+		if (state == 0)
+			adc->threshold_en[chan->channel] &= ~ADC_DATA_THRESHOLD_DIS_MASK;
+		else {
+			adc->threshold_en[chan->channel] &= ~ADC_DATA_THRESHOLD_DIS_MASK;
+			adc->threshold_en[chan->channel] |= ADC_DATA_THRESHOLD_HIGH_EN;
+		}
+	}
+
+	return 0;
+}
+
+static int intel_adc_read_event_config(struct iio_dev *iio,
+	const struct iio_chan_spec *chan, enum iio_event_type type,
+	enum iio_event_direction dir)
+{
+	struct intel_adc *adc = iio_priv(iio);
+	int val;
+
+	if (dir == IIO_EV_DIR_FALLING)
+		val = (adc->threshold_en[chan->channel] & ADC_DATA_THRESHOLD_LOW_EN) >> 8;
+	else
+		val = adc->threshold_en[chan->channel] & ADC_DATA_THRESHOLD_HIGH_EN;
+
+	return val;
+}
+
 static const struct iio_info intel_adc_info = {
 	.read_raw = intel_adc_read_raw,
+	.read_event_value = intel_adc_read_thresh,
+	.write_event_value = intel_adc_write_thresh,
+	.read_event_config = intel_adc_read_event_config,
+	.write_event_config = intel_adc_write_event_config,
 };
 
 static const struct iio_event_spec intel_adc_events[] = {
@@ -335,12 +427,8 @@ static const struct iio_event_spec intel_adc_events[] = {
 	}, {
 		.type = IIO_EV_TYPE_THRESH,
 		.dir = IIO_EV_DIR_FALLING,
-		.mask_separate = BIT(IIO_EV_INFO_VALUE),
-	}, {
-		.type = IIO_EV_TYPE_THRESH,
-		.dir = IIO_EV_DIR_EITHER,
-		.mask_separate = BIT(IIO_EV_INFO_ENABLE) |
-			BIT(IIO_EV_INFO_PERIOD),
+		.mask_separate = BIT(IIO_EV_INFO_VALUE) |
+			BIT(IIO_EV_INFO_ENABLE),
 	},
 };
 
-- 
2.7.4

