From 67611fa24ca07d61b110e69e1db130bf4df58f2c Mon Sep 17 00:00:00 2001
From: "pandith.n" <pandith.n@intel.com>
Date: Thu, 6 Feb 2020 13:53:30 +0530
Subject: [PATCH] REVERT-ME: Temporary enable D0i3 flow for PSE UART and TGPIO

The current hacks to allow d0i3 state through re-using existing
kernel runtime-powermanagement infrastructure for the following
PSE IO:
- UART
- TGPIO

Proper design is still under discussion involving Rafael Wysocki.

Signed-off-by: pandith.n <pandith.n@intel.com>
Signed-off-by: Tan, Raymond <raymond.tan@intel.com>
---
 drivers/ptp/ptp-intel-tgpio.c       | 109 ++++++++++++++++++++++++++++
 drivers/tty/serial/8250/8250_lpss.c | 137 ++++++++++++++++++++++++++++++++++++
 2 files changed, 246 insertions(+)

diff --git a/drivers/ptp/ptp-intel-tgpio.c b/drivers/ptp/ptp-intel-tgpio.c
index 5f0a1ea..879c19f 100644
--- a/drivers/ptp/ptp-intel-tgpio.c
+++ b/drivers/ptp/ptp-intel-tgpio.c
@@ -14,6 +14,7 @@
 #include <linux/pci.h>
 #include <linux/ptp_clock_kernel.h>
 #include <linux/spinlock.h>
+#include <linux/pm_runtime.h>
 
 #define TGPIOCTL(n)		(((n) * 0x40) + 0x00)
 #define TGPIOCOMPV31_0(n)	(((n) * 0x40) + 0x04)
@@ -113,6 +114,16 @@
 #define NSECS_PER_SEC		1000000000
 #define TGPIO_MAX_ADJ_TIME	999999900
 
+#define TGPIO_D0I3C 0x1000
+#define TGPIO_CGSR 0x1004
+
+
+
+#define TGPIO_D0I3_CIP BIT(0)
+#define TGPIO_D0I3_EN BIT(2)
+#define TGPIO_D0I3_RR BIT(3)
+#define TGPIO_CGSR_CG BIT(16)
+
 struct intel_tgpio {
 	struct ptp_clock_info	info;
 	struct ptp_clock	*clock;
@@ -368,6 +379,16 @@ static int intel_tgpio_enable(struct ptp_clock_info *info,
 	unsigned long		flags;
 	int			ret = -EOPNOTSUPP;
 
+	if(on) {
+                /* increase runtime_usage counter */
+                pm_runtime_get_sync(tgpio->dev);
+		printk(KERN_ERR "EHL OSE TGPIO enabled");
+         } else {
+                /* decrease runtime_usage counter */
+                pm_runtime_put_sync(tgpio->dev);
+		printk(KERN_ERR "EHL OSE TGPIO disabled");
+         }
+
 	spin_lock_irqsave(&tgpio->lock, flags);
 	switch (req->type) {
 	case PTP_CLK_REQ_EXTTS:
@@ -519,6 +540,7 @@ static int intel_tgpio_probe(struct pci_dev *pci, const struct pci_device_id *id
 
 	tgpio->base += 0x1000;
 
+
 	/* make sure all pins are disabled */
 	intel_tgpio_disable_all_pins(tgpio);
 
@@ -546,6 +568,11 @@ static int intel_tgpio_probe(struct pci_dev *pci, const struct pci_device_id *id
 	if (ret)
 		goto err1;
 
+
+        pm_runtime_set_autosuspend_delay(dev, 1000);
+        pm_runtime_use_autosuspend(dev);
+        pm_runtime_put_noidle(dev);
+        pm_runtime_allow(dev);
 	return 0;
 
 err1:
@@ -564,6 +591,85 @@ static void intel_tgpio_remove(struct pci_dev *pci)
 	ptp_clock_unregister(tgpio->clock);
 }
 
+
+#ifdef CONFIG_PM
+static int intel_tgpio_runtime_suspend(struct device *dev)
+{
+	struct pci_dev *pdev = container_of(dev, struct pci_dev, dev);
+	struct intel_tgpio *tgpio = pci_get_drvdata(pdev);
+	u32 d0i3c_reg;
+	u32 cgsr_reg;
+	unsigned long j0,j1,delay;
+
+	delay = msecs_to_jiffies(100);
+	j0 = jiffies;
+	j1 = j0 + delay;
+
+	cgsr_reg = intel_tgpio_readl(tgpio->base, TGPIO_CGSR);
+	intel_tgpio_writel(tgpio->base, TGPIO_CGSR, TGPIO_CGSR_CG);
+
+	d0i3c_reg = intel_tgpio_readl(tgpio->base, TGPIO_D0I3C);
+
+	if (d0i3c_reg & TGPIO_D0I3_CIP) {
+		dev_info(dev, "%s d0i3c CIP detected", __func__);
+	} else {
+		intel_tgpio_writel(tgpio->base, TGPIO_D0I3C, TGPIO_D0I3_EN);
+		d0i3c_reg = intel_tgpio_readl(tgpio->base, TGPIO_D0I3C);
+	}
+
+	while (time_before(jiffies, j1)) {
+		d0i3c_reg = intel_tgpio_readl(tgpio->base, TGPIO_D0I3C);
+		if (!(d0i3c_reg & TGPIO_D0I3_CIP)) {
+			break;
+		}
+	}
+
+	if (d0i3c_reg & TGPIO_D0I3_CIP) {
+		dev_info(dev, "%s: timeout waiting CIP to be cleared", __func__);
+	}
+
+	return 0;
+}
+
+static int intel_tgpio_runtime_resume(struct device *dev)
+{
+	struct pci_dev *pdev = container_of(dev, struct pci_dev, dev);
+	struct intel_tgpio *tgpio = pci_get_drvdata(pdev);
+	u32 d0i3c_reg;
+	u32 cgsr_reg;
+
+	cgsr_reg = intel_tgpio_readl(tgpio->base, TGPIO_CGSR);
+
+	if (cgsr_reg & TGPIO_CGSR_CG) {
+		dev_info(dev, "%s Clock Gated, release now...", __func__);
+		intel_tgpio_writel(tgpio->base, TGPIO_CGSR, (cgsr_reg & ~TGPIO_CGSR_CG));
+	}
+
+	d0i3c_reg = intel_tgpio_readl(tgpio->base, TGPIO_D0I3C);
+
+	if (d0i3c_reg & TGPIO_D0I3_CIP) {
+		dev_info(dev, "%s d0i3c CIP detected", __func__);
+	} else {
+
+		if (d0i3c_reg & TGPIO_D0I3_EN)
+			d0i3c_reg &= ~TGPIO_D0I3_EN;
+
+		if (d0i3c_reg & TGPIO_D0I3_RR)
+			d0i3c_reg |= TGPIO_D0I3_RR;
+
+		intel_tgpio_writel(tgpio->base, TGPIO_D0I3C, d0i3c_reg);
+		d0i3c_reg = intel_tgpio_readl(tgpio->base, TGPIO_D0I3C);
+	}
+	return 0;
+}
+#endif
+
+
+static const struct dev_pm_ops intel_tgpio_pm_ops = {
+             SET_RUNTIME_PM_OPS(intel_tgpio_runtime_suspend,intel_tgpio_runtime_resume, NULL)
+};
+
+
 static const struct pci_device_id intel_tgpio_id_table[] = {
 	{ PCI_VDEVICE(INTEL, 0x4b88), /* EHL */ },
 	{ PCI_VDEVICE(INTEL, 0x4b89), /* EHL */ },
@@ -576,6 +682,9 @@ static struct pci_driver intel_tgpio_driver = {
 	.id_table	= intel_tgpio_id_table,
 	.probe		= intel_tgpio_probe,
 	.remove		= intel_tgpio_remove,
+	.driver = {
+             .pm = &intel_tgpio_pm_ops,
+	}
 };
 
 module_pci_driver(intel_tgpio_driver);
diff --git a/drivers/tty/serial/8250/8250_lpss.c b/drivers/tty/serial/8250/8250_lpss.c
index 0c54223..0bfa35a 100644
--- a/drivers/tty/serial/8250/8250_lpss.c
+++ b/drivers/tty/serial/8250/8250_lpss.c
@@ -10,6 +10,8 @@
 #include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/rational.h>
+#include <linux/pm_runtime.h>
+
 
 #include <linux/dmaengine.h>
 #include <linux/dma/dw.h>
@@ -45,6 +47,25 @@
 #define BYT_TX_OVF_INT			0x820
 #define BYT_TX_OVF_INT_MASK		BIT(1)
 
+#define LPSS8250_D0I3C 0x1000
+#define LPSS8250_CGSR 0x1004
+
+#define LPSS8250_D0I3_CIP BIT(0)
+#define LPSS8250_D0I3_EN BIT(2)
+#define LPSS8250_D0I3_RR BIT(3)
+#define LPSS8250_CGSR_CG BIT(16)
+
+
+static inline void lpss8250_writel(void __iomem *base, u32 offset, u32 value)
+{
+	writel(value, base + offset);
+}
+
+static inline u32 lpss8250_readl(void __iomem *base, u32 offset)
+{
+	return readl(base + offset);
+}
+
 struct lpss8250;
 
 struct lpss8250_board {
@@ -62,6 +83,7 @@ struct lpss8250 {
 	struct dw_dma_chip dma_chip;
 	struct dw_dma_slave dma_param;
 	u8 dma_maxburst;
+  unsigned long base;
 };
 
 static inline struct lpss8250 *to_lpss8250(struct dw8250_port_data *data)
@@ -277,6 +299,7 @@ static int lpss8250_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	struct uart_8250_port uart;
 	struct lpss8250 *lpss;
 	int ret;
+	struct device *dev = &pdev->dev;
 
 	ret = pcim_enable_device(pdev);
 	if (ret)
@@ -310,6 +333,8 @@ static int lpss8250_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	if (!uart.port.membase)
 		return -ENOMEM;
 
+  lpss->base = uart.port.membase;
+
 	if (lpss->board->setup) {
 		ret = lpss->board->setup(lpss, &uart.port);
 		if (ret)
@@ -329,6 +354,13 @@ static int lpss8250_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	lpss->data.line = ret;
 
 	pci_set_drvdata(pdev, lpss);
+
+        pm_runtime_set_autosuspend_delay(dev, -1);
+        pm_runtime_use_autosuspend(dev);
+        pm_runtime_put_noidle(dev);
+        pm_runtime_allow(dev);
+
+
 	return 0;
 
 err_exit:
@@ -341,12 +373,18 @@ static int lpss8250_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 static void lpss8250_remove(struct pci_dev *pdev)
 {
 	struct lpss8250 *lpss = pci_get_drvdata(pdev);
+	struct device *dev = &pdev->dev;
+
+	pm_runtime_get_sync(dev);
 
 	serial8250_unregister_port(lpss->data.line);
 
 	if (lpss->board->exit)
 		lpss->board->exit(lpss);
 	pci_free_irq_vectors(pdev);
+
+	pm_runtime_disable(dev);
+	pm_runtime_put_noidle(dev);
 }
 
 static const struct lpss8250_board byt_board = {
@@ -367,6 +405,97 @@ static const struct lpss8250_board qrk_board = {
 	.exit = qrk_serial_exit,
 };
 
+#ifdef CONFIG_PM_SLEEP
+static int lpss8250_suspend(struct device *dev)
+{
+	struct lpss8250 *lpss = dev_get_drvdata(dev);
+
+	serial8250_suspend_port(lpss->data.line);
+
+	return 0;
+}
+
+static int lpss8250_resume(struct device *dev)
+{
+	struct lpss8250 *lpss = dev_get_drvdata(dev);
+
+	serial8250_resume_port(lpss->data.line);
+
+	return 0;
+}
+#endif /* CONFIG_PM_SLEEP */
+
+#ifdef CONFIG_PM
+static int lpss8250_runtime_suspend(struct device *dev)
+{
+	struct lpss8250 *lpss = dev_get_drvdata(dev);
+	u32 d0i3c_reg;
+	u32 cgsr_reg;
+	unsigned long j0,j1,delay;
+
+	delay = msecs_to_jiffies(100);
+	j0 = jiffies;
+	j1 = j0 + delay;
+
+	cgsr_reg = lpss8250_readl(lpss->base, LPSS8250_CGSR);
+	lpss8250_writel(lpss->base, LPSS8250_CGSR, LPSS8250_CGSR_CG);
+
+	d0i3c_reg = lpss8250_readl(lpss->base, LPSS8250_D0I3C);
+
+	if (d0i3c_reg & LPSS8250_D0I3_CIP) {
+		dev_info(dev, "%s d0i3c CIP detected", __func__);
+	} else {
+		lpss8250_writel(lpss->base, LPSS8250_D0I3C, LPSS8250_D0I3_EN);
+		d0i3c_reg = lpss8250_readl(lpss->base, LPSS8250_D0I3C);
+	}
+
+	while (time_before(jiffies, j1)) {
+		d0i3c_reg = lpss8250_readl(lpss->base, LPSS8250_D0I3C);
+		if (!(d0i3c_reg & LPSS8250_D0I3_CIP)) {
+			break;
+		}
+	}
+
+	if (d0i3c_reg & LPSS8250_D0I3_CIP) {
+		dev_info(dev, "%s: timeout waiting CIP to be cleared", __func__);
+	}
+
+	return 0;
+}
+
+static int lpss8250_runtime_resume(struct device *dev)
+{
+	struct lpss8250 *lpss = dev_get_drvdata(dev);
+	u32 d0i3c_reg;
+	u32 cgsr_reg;
+
+	cgsr_reg = lpss8250_readl(lpss->base, LPSS8250_CGSR);
+
+	if (cgsr_reg & LPSS8250_CGSR_CG) {
+		dev_info(dev, "%s Clock Gated, release now...", __func__);
+		lpss8250_writel(lpss->base, LPSS8250_CGSR, (cgsr_reg & ~LPSS8250_CGSR_CG));
+	}
+
+	d0i3c_reg = lpss8250_readl(lpss->base, LPSS8250_D0I3C);
+
+	if (d0i3c_reg & LPSS8250_D0I3_CIP) {
+		dev_info(dev, "%s d0i3c CIP detected", __func__);
+	} else {
+
+		if (d0i3c_reg & LPSS8250_D0I3_EN)
+			d0i3c_reg &= ~LPSS8250_D0I3_EN;
+
+		if (d0i3c_reg & LPSS8250_D0I3_RR)
+			d0i3c_reg |= LPSS8250_D0I3_RR;
+
+		lpss8250_writel(lpss->base, LPSS8250_D0I3C, d0i3c_reg);
+		d0i3c_reg = lpss8250_readl(lpss->base, LPSS8250_D0I3C);
+	}
+
+	return 0;
+}
+#endif /* CONFIG_PM */
+
 static const struct pci_device_id pci_ids[] = {
 	{ PCI_DEVICE_DATA(INTEL, QRK_UARTx, &qrk_board) },
 	{ PCI_DEVICE_DATA(INTEL, EHL_UART0, &ehl_board) },
@@ -385,11 +514,19 @@ static const struct pci_device_id pci_ids[] = {
 };
 MODULE_DEVICE_TABLE(pci, pci_ids);
 
+static const struct dev_pm_ops lpss8250_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lpss8250_suspend, lpss8250_resume)
+	SET_RUNTIME_PM_OPS(lpss8250_runtime_suspend, lpss8250_runtime_resume, NULL)
+};
+
 static struct pci_driver lpss8250_pci_driver = {
 	.name           = "8250_lpss",
 	.id_table       = pci_ids,
 	.probe          = lpss8250_probe,
 	.remove         = lpss8250_remove,
+	.driver					= {
+		.pm		= &lpss8250_pm_ops,
+	}
 };
 
 module_pci_driver(lpss8250_pci_driver);
-- 
2.7.4

