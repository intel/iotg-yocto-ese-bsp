From 1d347ffa56b5116c16338d10441206c864dc31f4 Mon Sep 17 00:00:00 2001
From: "Wong, Vincent Por Yin" <vincent.por.yin.wong@intel.com>
Date: Tue, 17 Dec 2019 14:58:58 +0800
Subject: [PATCH 3/5] net: stmmac: introduce AF_XDP RX HW timestamps

Signed-off-by: Wong, Vincent Por Yin <vincent.por.yin.wong@intel.com>
---
 .../net/ethernet/stmicro/stmmac/stmmac_main.c |  4 ++-
 .../net/ethernet/stmicro/stmmac/stmmac_xsk.c  | 34 +++++++++++++++----
 samples/bpf/xdpsock_user.c                    |  7 +++-
 3 files changed, 36 insertions(+), 9 deletions(-)

diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index c81d3a3a281a..8ac14ee3ba76 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@ -4599,9 +4599,11 @@ static int stmmac_rx(struct stmmac_priv *priv, int limit, u32 queue)
 						len, dma_dir);
 
 			xdp.data = page_address(buf->page);
-			xdp.data_meta = xdp.data;
+			xdp.data_meta = xdp.data - sizeof(u64);
 			xdp.data_hard_start = xdp.data;
 			xdp.data_end = xdp.data + len;
+			stmmac_get_rx_hwtstamp(priv, p, np,
+					       (u64 *) xdp.data_meta);
 
 			skb = stmmac_run_xdp(rx_q, &xdp);
 
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_xsk.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_xsk.c
index d26f065527c3..f412bd288be2 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_xsk.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_xsk.c
@@ -573,8 +573,10 @@ int stmmac_rx_zc(struct stmmac_priv *priv, int budget, u32 queue)
 	xdp.rxq = &rx_q->xdp_rxq;
 
 	while (likely(total_rx_packets < (unsigned int)budget)) {
+		struct skb_shared_hwtstamps *shhwtstamp = NULL;
+		struct dma_desc *rx_desc, *nx_desc;
 		struct stmmac_rx_buffer *buf;
-		struct dma_desc *rx_desc;
+		unsigned int next_entry;
 		unsigned int size;
 		int status;
 
@@ -606,8 +608,12 @@ int stmmac_rx_zc(struct stmmac_priv *priv, int budget, u32 queue)
 
 		size = stmmac_get_rx_frame_len(priv, rx_desc,
 					       coe);
-		if (!size)
-			break;
+
+		/* If context descriptor, size = 0. So, continue to next desc */
+		if (!size) {
+			stmmac_inc_ntc(rx_q);
+			continue;
+		}
 
 		buf = stmmac_get_rx_buffer_zc(rx_q, size);
 
@@ -618,11 +624,22 @@ int stmmac_rx_zc(struct stmmac_priv *priv, int budget, u32 queue)
 			continue;
 		}
 
+		/* Get the next desc for reading HW T/S */
+		stmmac_inc_ntc(rx_q);
+		next_entry = rx_q->cur_rx;
+		if (priv->extend_desc)
+			nx_desc = (struct dma_desc *)(rx_q->dma_erx +
+						      next_entry);
+		else
+			nx_desc = rx_q->dma_rx + next_entry;
+
 		xdp.data = buf->umem_addr;
-		xdp.data_meta = xdp.data;
+		xdp.data_meta = xdp.data - sizeof(u64);
 		xdp.data_hard_start = xdp.data - XDP_PACKET_HEADROOM;
 		xdp.data_end = xdp.data + size;
 		xdp.handle = buf->umem_handle;
+		stmmac_get_rx_hwtstamp(priv, rx_desc, nx_desc,
+				       (u64 *) xdp.data_meta);
 
 		xdp_res = stmmac_run_xdp_zc(rx_q, &xdp);
 		if (xdp_res) {
@@ -637,7 +654,6 @@ int stmmac_rx_zc(struct stmmac_priv *priv, int budget, u32 queue)
 			total_rx_packets++;
 
 			fill_count++;
-			stmmac_inc_ntc(rx_q);
 			continue;
 		}
 
@@ -650,14 +666,18 @@ int stmmac_rx_zc(struct stmmac_priv *priv, int budget, u32 queue)
 
 		fill_count++;
 
-		stmmac_inc_ntc(rx_q);
-
 		if (eth_skb_pad(skb))
 			continue;
 
 		total_rx_bytes += skb->len;
 		total_rx_packets++;
 
+		/* Get HW tstamp into SKB. */
+		shhwtstamp = skb_hwtstamps(skb);
+		memset(shhwtstamp, 0, sizeof(struct skb_shared_hwtstamps));
+		stmmac_get_rx_hwtstamp(priv, rx_desc, nx_desc,
+				       &shhwtstamp->hwtstamp);
+
 		/* Use HW to strip VLAN header before fallback
 		 * to SW.
 		 */
diff --git a/samples/bpf/xdpsock_user.c b/samples/bpf/xdpsock_user.c
index e960b3e5c670..fe024ca490ee 100644
--- a/samples/bpf/xdpsock_user.c
+++ b/samples/bpf/xdpsock_user.c
@@ -587,11 +587,16 @@ static void rx_drop(struct xsk_socket_info *xsk, struct pollfd *fds)
 	for (i = 0; i < rcvd; i++) {
 		u64 addr = xsk_ring_cons__rx_desc(&xsk->rx, idx_rx)->addr;
 		u32 len = xsk_ring_cons__rx_desc(&xsk->rx, idx_rx++)->len;
-		u64 orig = xsk_umem__extract_addr(addr);
 
 		addr = xsk_umem__add_offset_to_addr(addr);
 		char *pkt = xsk_umem__get_data(xsk->umem->buffer, addr);
 
+		printf("Packet data @ %p and timestamp %llx\n",
+				pkt,
+				*(uint64_t *)(pkt - sizeof(uint64_t)));
+
+		u64 orig = xsk_umem__extract_addr(addr);
+
 		hex_dump(pkt, len, addr);
 		*xsk_ring_prod__fill_addr(&xsk->umem->fq, idx_fq++) = orig;
 	}
-- 
2.17.0

