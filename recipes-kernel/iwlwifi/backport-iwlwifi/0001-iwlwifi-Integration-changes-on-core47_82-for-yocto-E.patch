From de0ce4284b6022523d86906ba89dc29005374ff5 Mon Sep 17 00:00:00 2001
From: Karthik D A <karthik.d.a@intel.com>
Date: Mon, 23 Dec 2019 17:09:17 +0530
Subject: [PATCH] iwlwifi:Integration changes on core47_82 for yocto EHL

Integration from change ID:f3acb0e84e73c61d981ebd5ad89b7764cfd4e720
to change ID:6ff05659b9785a9f8db787bfb53f7ef1b5d1dd65

Signed-off-by:Karthik D A <karthik.d.a@intel.com>
---
 iwlwifi-stack-dev/Kconfig.local                    |   6 +
 iwlwifi-stack-dev/MAINTAINERS                      |   1 +
 iwlwifi-stack-dev/backport-include/linux/mm.h      |   9 +-
 iwlwifi-stack-dev/backport-include/linux/pci.h     |   4 +
 iwlwifi-stack-dev/compat/Kconfig                   |  10 ++
 iwlwifi-stack-dev/compat/Makefile                  |   1 +
 iwlwifi-stack-dev/compat/lib-crypto-arc4.c         |  74 +++++++++++
 iwlwifi-stack-dev/defconfigs/prune-chromeos        |   1 +
 .../net/wireless/intel/iwlwifi/Kconfig.noupstream  |  13 ++
 .../drivers/net/wireless/intel/iwlwifi/dvm/led.c   |   3 +
 .../drivers/net/wireless/intel/iwlwifi/fw/acpi.c   |  14 +-
 .../drivers/net/wireless/intel/iwlwifi/fw/dbg.c    |   5 +-
 .../drivers/net/wireless/intel/iwlwifi/fw/img.h    |   2 +-
 .../net/wireless/intel/iwlwifi/iwl-devtrace-data.h |   8 +-
 .../drivers/net/wireless/intel/iwlwifi/iwl-drv.c   |  24 +++-
 .../drivers/net/wireless/intel/iwlwifi/iwl-prph.h  |   8 ++
 .../drivers/net/wireless/intel/iwlwifi/mvm/fw.c    |  25 +++-
 .../drivers/net/wireless/intel/iwlwifi/mvm/led.c   |   3 +
 .../net/wireless/intel/iwlwifi/mvm/mac80211.c      | 126 ++++++++++++++++++
 .../drivers/net/wireless/intel/iwlwifi/mvm/power.c |   2 -
 .../drivers/net/wireless/intel/iwlwifi/mvm/sta.c   | 144 ++++++++++++---------
 .../drivers/net/wireless/intel/iwlwifi/mvm/utils.c |  12 +-
 .../wireless/intel/iwlwifi/pcie/ctxt-info-gen3.c   |  36 ++++--
 .../drivers/net/wireless/intel/iwlwifi/pcie/drv.c  | 114 ++++++++--------
 .../net/wireless/intel/iwlwifi/pcie/trans-gen2.c   |  26 ++++
 .../net/wireless/intel/iwlwifi/pcie/trans.c        |  15 ++-
 .../net/wireless/intel/iwlwifi/pcie/tx-gen2.c      |  40 +++---
 .../drivers/net/wireless/intel/iwlwifi/pcie/tx.c   |  14 +-
 iwlwifi-stack-dev/include/crypto/arc4.h            |  10 ++
 iwlwifi-stack-dev/include/crypto/backport-arc4.h   |  23 ++++
 iwlwifi-stack-dev/include/net/fq.h                 |   8 ++
 iwlwifi-stack-dev/include/net/fq_impl.h            |  10 +-
 .../intc-scripts/chromeOS/copy-code.sh             |  13 +-
 .../intc-scripts/chromeOS/hdrs/iwl-chrome.h        |  34 ++++-
 .../intc-scripts/chromeOS/hdrs/mac80211-bp.h       |  10 ++
 .../intc-scripts/chromeOS/iwlwifi.patch            |  16 +++
 iwlwifi-stack-dev/intc-scripts/publishable-options |   1 +
 iwlwifi-stack-dev/local-symbols                    |   3 +
 iwlwifi-stack-dev/net/mac80211/Kconfig             |   6 +-
 iwlwifi-stack-dev/net/mac80211/cfg.c               |   9 +-
 iwlwifi-stack-dev/net/mac80211/ieee80211_i.h       |   6 +-
 iwlwifi-stack-dev/net/mac80211/key.h               |   2 -
 iwlwifi-stack-dev/net/mac80211/main.c              |  16 +--
 iwlwifi-stack-dev/net/mac80211/mlme.c              |   6 -
 iwlwifi-stack-dev/net/mac80211/tkip.c              |  27 +---
 iwlwifi-stack-dev/net/mac80211/tkip.h              |  19 +--
 iwlwifi-stack-dev/net/mac80211/wep.c               |  73 +----------
 iwlwifi-stack-dev/net/mac80211/wep.h               |  12 +-
 iwlwifi-stack-dev/net/mac80211/wpa.c               |  14 --
 iwlwifi-stack-dev/net/wireless/Kconfig             |   2 +
 .../net/wireless/lib80211_crypt_tkip.c             |  48 +++----
 .../net/wireless/lib80211_crypt_wep.c              |  51 ++------
 iwlwifi-stack-dev/net/wireless/scan.c              |  30 +++--
 53 files changed, 733 insertions(+), 456 deletions(-)
 create mode 100644 iwlwifi-stack-dev/compat/lib-crypto-arc4.c
 create mode 100644 iwlwifi-stack-dev/include/crypto/arc4.h
 create mode 100644 iwlwifi-stack-dev/include/crypto/backport-arc4.h

diff --git a/iwlwifi-stack-dev/Kconfig.local b/iwlwifi-stack-dev/Kconfig.local
index 33dd94b..893ea64 100644
--- a/iwlwifi-stack-dev/Kconfig.local
+++ b/iwlwifi-stack-dev/Kconfig.local
@@ -76,6 +76,12 @@ config BACKPORTED_BPAUTO_ASN1_DECODER
 config BACKPORTED_BPAUTO_PKCS7
 	tristate
 	default BPAUTO_PKCS7
+config BACKPORTED_BPAUTO_CRYPTO_LIB_ARC4
+	tristate
+	default BPAUTO_CRYPTO_LIB_ARC4
+config BACKPORTED_BPAUTO_BUILD_CRYPTO_LIB_ARC4
+	tristate
+	default BPAUTO_BUILD_CRYPTO_LIB_ARC4
 config BACKPORTED_CFG80211
 	tristate
 	default CFG80211
diff --git a/iwlwifi-stack-dev/MAINTAINERS b/iwlwifi-stack-dev/MAINTAINERS
index 32d4444..3f8a937 100644
--- a/iwlwifi-stack-dev/MAINTAINERS
+++ b/iwlwifi-stack-dev/MAINTAINERS
@@ -4036,6 +4036,7 @@ F:	crypto/
 F:	drivers/crypto/
 F:	include/crypto/
 F:	include/linux/crypto*
+F:	lib/crypto/
 
 CRYPTOGRAPHIC RANDOM NUMBER GENERATOR
 M:	Neil Horman <nhorman@tuxdriver.com>
diff --git a/iwlwifi-stack-dev/backport-include/linux/mm.h b/iwlwifi-stack-dev/backport-include/linux/mm.h
index 0806f4d..5253e1d 100644
--- a/iwlwifi-stack-dev/backport-include/linux/mm.h
+++ b/iwlwifi-stack-dev/backport-include/linux/mm.h
@@ -103,6 +103,13 @@ static inline void *kvzalloc(size_t size, gfp_t flags)
 {
 	return kvmalloc(size, flags | __GFP_ZERO);
 }
-#endif
+#endif /* < 4.12 */
+
+#if LINUX_VERSION_IS_LESS(4,18,0)
+static inline void *kvcalloc(size_t n, size_t size, gfp_t flags)
+{
+	return kvmalloc_array(n, size, flags | __GFP_ZERO);
+}
+#endif /* < 4.18 */
 
 #endif /* __BACKPORT_MM_H */
diff --git a/iwlwifi-stack-dev/backport-include/linux/pci.h b/iwlwifi-stack-dev/backport-include/linux/pci.h
index 341660b..688680d 100644
--- a/iwlwifi-stack-dev/backport-include/linux/pci.h
+++ b/iwlwifi-stack-dev/backport-include/linux/pci.h
@@ -3,6 +3,10 @@
 #include_next <linux/pci.h>
 #include <linux/version.h>
 
+#if LINUX_VERSION_IS_LESS(5,4,0)
+#include <linux/pci-aspm.h>
+#endif
+
 #ifndef module_pci_driver
 /**
  * module_pci_driver() - Helper macro for registering a PCI driver
diff --git a/iwlwifi-stack-dev/compat/Kconfig b/iwlwifi-stack-dev/compat/Kconfig
index 4abaa0e..a1c26fe 100644
--- a/iwlwifi-stack-dev/compat/Kconfig
+++ b/iwlwifi-stack-dev/compat/Kconfig
@@ -165,3 +165,13 @@ config BPAUTO_ASN1_DECODER
 config BPAUTO_PKCS7
 	bool
 	#h-file crypto/pkcs7.h
+
+config BPAUTO_CRYPTO_LIB_ARC4
+	bool
+
+config BPAUTO_BUILD_CRYPTO_LIB_ARC4
+	bool
+	default y if BPAUTO_CRYPTO_LIB_ARC4
+	depends on !(CRYPTO_LIB_ARC4=y || CRYPTO_LIB_ARC4=m)
+	#h-file crypto/arc4.h
+	#c-file lib/crypto/arc4.c
diff --git a/iwlwifi-stack-dev/compat/Makefile b/iwlwifi-stack-dev/compat/Makefile
index 1f62e4f..c1af0ce 100644
--- a/iwlwifi-stack-dev/compat/Makefile
+++ b/iwlwifi-stack-dev/compat/Makefile
@@ -77,3 +77,4 @@ compat-$(CPTCFG_BPAUTO_RHASHTABLE) += lib-rhashtable.o
 compat-$(CPTCFG_BPAUTO_PUBLIC_KEY) += 
 compat-$(CPTCFG_BPAUTO_BUCKET_LOCKS) += lib-bucket_locks.o
 compat-$(CPTCFG_BPAUTO_PKCS7) += 
+compat-$(CPTCFG_BPAUTO_BUILD_CRYPTO_LIB_ARC4) += lib-crypto-arc4.o
diff --git a/iwlwifi-stack-dev/compat/lib-crypto-arc4.c b/iwlwifi-stack-dev/compat/lib-crypto-arc4.c
new file mode 100644
index 0000000..c2020f1
--- /dev/null
+++ b/iwlwifi-stack-dev/compat/lib-crypto-arc4.c
@@ -0,0 +1,74 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Cryptographic API
+ *
+ * ARC4 Cipher Algorithm
+ *
+ * Jon Oberheide <jon@oberheide.org>
+ */
+
+#include <crypto/arc4.h>
+#include <linux/module.h>
+
+int arc4_setkey(struct arc4_ctx *ctx, const u8 *in_key, unsigned int key_len)
+{
+	int i, j = 0, k = 0;
+
+	ctx->x = 1;
+	ctx->y = 0;
+
+	for (i = 0; i < 256; i++)
+		ctx->S[i] = i;
+
+	for (i = 0; i < 256; i++) {
+		u32 a = ctx->S[i];
+
+		j = (j + in_key[k] + a) & 0xff;
+		ctx->S[i] = ctx->S[j];
+		ctx->S[j] = a;
+		if (++k >= key_len)
+			k = 0;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(arc4_setkey);
+
+void arc4_crypt(struct arc4_ctx *ctx, u8 *out, const u8 *in, unsigned int len)
+{
+	u32 *const S = ctx->S;
+	u32 x, y, a, b;
+	u32 ty, ta, tb;
+
+	if (len == 0)
+		return;
+
+	x = ctx->x;
+	y = ctx->y;
+
+	a = S[x];
+	y = (y + a) & 0xff;
+	b = S[y];
+
+	do {
+		S[y] = a;
+		a = (a + b) & 0xff;
+		S[x] = b;
+		x = (x + 1) & 0xff;
+		ta = S[x];
+		ty = (y + ta) & 0xff;
+		tb = S[ty];
+		*out++ = *in++ ^ S[a];
+		if (--len == 0)
+			break;
+		y = ty;
+		a = ta;
+		b = tb;
+	} while (true);
+
+	ctx->x = x;
+	ctx->y = y;
+}
+EXPORT_SYMBOL(arc4_crypt);
+
+MODULE_LICENSE("GPL");
diff --git a/iwlwifi-stack-dev/defconfigs/prune-chromeos b/iwlwifi-stack-dev/defconfigs/prune-chromeos
index 476a28d..2a43600 100644
--- a/iwlwifi-stack-dev/defconfigs/prune-chromeos
+++ b/iwlwifi-stack-dev/defconfigs/prune-chromeos
@@ -21,6 +21,7 @@ CPTCFG_IWLXVT=y
 CPTCFG_IWLWIFI_NUM_CHANNELS=1
 # CPTCFG_IWLMVM_ADVANCED_QUOTA_MGMT is not set
 CPTCFG_IWLMVM_VENDOR_CMDS=y
+# CPTCFG_IWLMVM_VENDOR_TCM_EVENTS is not set
 CPTCFG_IWLWIFI_DISALLOW_OLDER_FW=y
 # CPTCFG_MAC80211_LATENCY_MEASUREMENTS is not set
 # CPTCFG_IWLWIFI_DEBUG_HOST_CMD_ENABLED is not set
diff --git a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/Kconfig.noupstream b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/Kconfig.noupstream
index 03ad49d..a645168 100644
--- a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/Kconfig.noupstream
+++ b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/Kconfig.noupstream
@@ -92,6 +92,19 @@ config IWLMVM_VENDOR_CMDS
 	  This option mostly exists for non-upstream tagging, so best
 	  leave it set to Y.
 
+config IWLMVM_VENDOR_TCM_EVENTS
+	bool "enable TCM vendor events"
+	depends on IWLMVM_VENDOR_CMDS
+	default y
+	help
+	  This option enables vendor TCM events to userspace that can
+	  be used to adjust certain parameters depending on the
+	  traffic conditions.  These events can become rather noisy
+	  with standard wpa_supplicant, since it prints out 3 debug
+	  messages every time the event is received (as an unknown
+	  event).  When used with standard wpa_supplicant, it is
+	  recommended to disable this option.
+
 config IWLMVM_TDLS_PEER_CACHE
 	bool "enable TDLS peer caching and traffic monitoring"
 	depends on IWLMVM_VENDOR_CMDS
diff --git a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/dvm/led.c b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/dvm/led.c
index 04c236e..bf6b8cb 100644
--- a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/dvm/led.c
+++ b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/dvm/led.c
@@ -181,6 +181,9 @@ void iwl_leds_init(struct iwl_priv *priv)
 
 	priv->led.name = kasprintf(GFP_KERNEL, "%s-led",
 				   wiphy_name(priv->hw->wiphy));
+	if (!priv->led.name)
+		return;
+
 	priv->led.brightness_set = iwl_led_brightness_set;
 	priv->led.blink_set = iwl_led_blink_set;
 	priv->led.max_brightness = 1;
diff --git a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/fw/acpi.c b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/fw/acpi.c
index fe7f831..8ce99ea 100644
--- a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/fw/acpi.c
+++ b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/fw/acpi.c
@@ -464,13 +464,17 @@ bool iwl_sar_geo_support(struct iwl_fw_runtime *fwrt)
 	 * firmware versions.  Unfortunately, we don't have a TLV API
 	 * flag to rely on, so rely on the major version which is in
 	 * the first byte of ucode_ver.  This was implemented
-	 * initially on version 38 and then backported to 36, 29 and
-	 * 17.
+	 * initially on version 38 and then backported to 17.  It was
+	 * also backported to 29, but only for 7265D devices.  The
+	 * intention was to have it in 36 as well, but not all 8000
+	 * family got this feature enabled.  The 8000 family is the
+	 * only one using version 36, so skip this version entirely.
 	 */
 	return IWL_UCODE_SERIAL(fwrt->fw->ucode_ver) >= 38 ||
-	       IWL_UCODE_SERIAL(fwrt->fw->ucode_ver) == 36 ||
-	       IWL_UCODE_SERIAL(fwrt->fw->ucode_ver) == 29 ||
-	       IWL_UCODE_SERIAL(fwrt->fw->ucode_ver) == 17;
+	       IWL_UCODE_SERIAL(fwrt->fw->ucode_ver) == 17 ||
+	       (IWL_UCODE_SERIAL(fwrt->fw->ucode_ver) == 29 &&
+		((fwrt->trans->hw_rev & CSR_HW_REV_TYPE_MSK) ==
+		 CSR_HW_REV_TYPE_7265D));
 }
 IWL_EXPORT_SYMBOL(iwl_sar_geo_support);
 
diff --git a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/fw/dbg.c b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/fw/dbg.c
index 48d5c17..705328f 100644
--- a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/fw/dbg.c
+++ b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/fw/dbg.c
@@ -646,6 +646,7 @@ static struct scatterlist *alloc_sgtable(int size)
 				if (new_page)
 					__free_page(new_page);
 			}
+			kfree(table);
 			return NULL;
 		}
 		alloc_size = min_t(int, size, PAGE_SIZE);
@@ -1203,13 +1204,15 @@ static bool iwl_ini_txf_iter(struct iwl_fw_runtime *fwrt,
 			iter->lmac = 0;
 	}
 
-	if (!iter->internal_txf)
+	if (!iter->internal_txf) {
 		for (iter->fifo++; iter->fifo < txf_num; iter->fifo++) {
 			iter->fifo_size =
 				cfg->lmac[iter->lmac].txfifo_size[iter->fifo];
 			if (iter->fifo_size && (lmac_bitmap & BIT(iter->fifo)))
 				return true;
 		}
+		iter->fifo--;
+	}
 
 	iter->internal_txf = true;
 
diff --git a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/fw/img.h b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/fw/img.h
index 0e289de..69bd9df 100644
--- a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/fw/img.h
+++ b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/fw/img.h
@@ -271,7 +271,7 @@ struct iwl_fw_ini_active_triggers {
 struct iwl_fw {
 	u32 ucode_ver;
 
-	char fw_version[ETHTOOL_FWVERS_LEN];
+	char fw_version[64];
 
 	/* ucode images */
 	struct fw_img img[IWL_UCODE_TYPE_MAX];
diff --git a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/iwl-devtrace-data.h b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/iwl-devtrace-data.h
index 420e6d7..6fcacb9 100644
--- a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/iwl-devtrace-data.h
+++ b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/iwl-devtrace-data.h
@@ -2,7 +2,7 @@
  *
  * Copyright(c) 2009 - 2014 Intel Corporation. All rights reserved.
  * Copyright(c) 2015        Intel Deutschland GmbH
- * Copyright(c) 2018        Intel Corporation
+ * Copyright(c) 2018 - 2019 Intel Corporation
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -32,16 +32,18 @@
 
 TRACE_EVENT(iwlwifi_dev_tx_tb,
 	TP_PROTO(const struct device *dev, struct sk_buff *skb,
-		 u8 *data_src, size_t data_len),
-	TP_ARGS(dev, skb, data_src, data_len),
+		 u8 *data_src, dma_addr_t phys, size_t data_len),
+	TP_ARGS(dev, skb, data_src, phys, data_len),
 	TP_STRUCT__entry(
 		DEV_ENTRY
+		__field(u64, phys)
 
 		__dynamic_array(u8, data,
 				iwl_trace_data(skb) ? data_len : 0)
 	),
 	TP_fast_assign(
 		DEV_ASSIGN;
+		__entry->phys = phys;
 		if (iwl_trace_data(skb))
 			memcpy(__get_dynamic_array(data), data_src, data_len);
 	),
diff --git a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/iwl-drv.c b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/iwl-drv.c
index 7ff92af..1be35fa 100644
--- a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/iwl-drv.c
+++ b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/iwl-drv.c
@@ -740,6 +740,16 @@ static void iwl_set_ucode_capabilities(struct iwl_drv *drv, const u8 *data,
 	}
 }
 
+static const char *iwl_reduced_fw_name(struct iwl_drv *drv)
+{
+	const char *name = drv->firmware_name;
+
+	if (strncmp(name, "iwlwifi-", 8) == 0)
+		name += 8;
+
+	return name;
+}
+
 static int iwl_parse_v1_v2_firmware(struct iwl_drv *drv,
 				    const struct firmware *ucode_raw,
 				    struct iwl_firmware_pieces *pieces)
@@ -798,12 +808,12 @@ static int iwl_parse_v1_v2_firmware(struct iwl_drv *drv,
 
 	snprintf(drv->fw.fw_version,
 		 sizeof(drv->fw.fw_version),
-		 "%u.%u.%u.%u%s",
+		 "%u.%u.%u.%u%s %s",
 		 IWL_UCODE_MAJOR(drv->fw.ucode_ver),
 		 IWL_UCODE_MINOR(drv->fw.ucode_ver),
 		 IWL_UCODE_API(drv->fw.ucode_ver),
 		 IWL_UCODE_SERIAL(drv->fw.ucode_ver),
-		 buildstr);
+		 buildstr, iwl_reduced_fw_name(drv));
 
 	/* Verify size of file vs. image size info in file's header */
 
@@ -894,12 +904,12 @@ static int iwl_parse_tlv_firmware(struct iwl_drv *drv,
 
 	snprintf(drv->fw.fw_version,
 		 sizeof(drv->fw.fw_version),
-		 "%u.%u.%u.%u%s",
+		 "%u.%u.%u.%u%s %s",
 		 IWL_UCODE_MAJOR(drv->fw.ucode_ver),
 		 IWL_UCODE_MINOR(drv->fw.ucode_ver),
 		 IWL_UCODE_API(drv->fw.ucode_ver),
 		 IWL_UCODE_SERIAL(drv->fw.ucode_ver),
-		 buildstr);
+		 buildstr, iwl_reduced_fw_name(drv));
 
 	data = ucode->data;
 
@@ -1178,11 +1188,13 @@ fw_dbg_conf:
 			if (strncmp(drv->fw.human_readable, "stream:", 7))
 				snprintf(drv->fw.fw_version,
 					 sizeof(drv->fw.fw_version),
-					"%u.%08x.%u", major, minor, local_comp);
+					"%u.%08x.%u %s", major, minor,
+					local_comp, iwl_reduced_fw_name(drv));
 			else
 				snprintf(drv->fw.fw_version,
 					 sizeof(drv->fw.fw_version),
-					"%u.%u.%u", major, minor, local_comp);
+					"%u.%u.%u %s", major, minor,
+					local_comp, iwl_reduced_fw_name(drv));
 			break;
 			}
 		case IWL_UCODE_TLV_FW_DBG_DEST: {
diff --git a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/iwl-prph.h b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/iwl-prph.h
index 9bd76da..2f045cf 100644
--- a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/iwl-prph.h
+++ b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/iwl-prph.h
@@ -429,6 +429,9 @@ enum aux_misc_master1_en {
 #define UMAG_SB_CPU_1_STATUS		0xA038C0
 #define UMAG_SB_CPU_2_STATUS		0xA038C4
 #define UMAG_GEN_HW_STATUS		0xA038C8
+#define UREG_UMAC_CURRENT_PC		0xa05c18
+#define UREG_LMAC1_CURRENT_PC		0xa05c1c
+#define UREG_LMAC2_CURRENT_PC		0xa05c20
 
 /* For UMAG_GEN_HW_STATUS reg check */
 enum {
@@ -452,6 +455,11 @@ enum {
 #define PERSISTENCE_BIT			BIT(12)
 #define PREG_WFPM_ACCESS		BIT(12)
 
+#define HPM_HIPM_GEN_CFG			0xA03458
+#define HPM_HIPM_GEN_CFG_CR_PG_EN		BIT(0)
+#define HPM_HIPM_GEN_CFG_CR_SLP_EN		BIT(1)
+#define HPM_HIPM_GEN_CFG_CR_FORCE_ACTIVE	BIT(10)
+
 #define UREG_DOORBELL_TO_ISR6		0xA05C04
 #define UREG_DOORBELL_TO_ISR6_NMI_BIT	BIT(0)
 
diff --git a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/mvm/fw.c b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/mvm/fw.c
index 089d6e6..35ff3f4 100644
--- a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/mvm/fw.c
+++ b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/mvm/fw.c
@@ -384,21 +384,34 @@ static int iwl_mvm_load_ucode_wait_alive(struct iwl_mvm *mvm,
 	if (ret) {
 		struct iwl_trans *trans = mvm->trans;
 
-		if (ret == -ETIMEDOUT)
-			iwl_fw_dbg_error_collect(&mvm->fwrt,
-						 FW_DBG_TRIGGER_ALIVE_TIMEOUT);
-
-		if (trans->cfg->device_family >= IWL_DEVICE_FAMILY_22000)
+		if (trans->cfg->device_family >= IWL_DEVICE_FAMILY_22000) {
 			IWL_ERR(mvm,
 				"SecBoot CPU1 Status: 0x%x, CPU2 Status: 0x%x\n",
 				iwl_read_umac_prph(trans, UMAG_SB_CPU_1_STATUS),
 				iwl_read_umac_prph(trans,
 						   UMAG_SB_CPU_2_STATUS));
-		else if (trans->cfg->device_family >= IWL_DEVICE_FAMILY_8000)
+			IWL_ERR(mvm, "UMAC PC: 0x%x\n",
+				iwl_read_umac_prph(trans,
+						   UREG_UMAC_CURRENT_PC));
+			IWL_ERR(mvm, "LMAC PC: 0x%x\n",
+				iwl_read_umac_prph(trans,
+						   UREG_LMAC1_CURRENT_PC));
+			if (iwl_mvm_is_cdb_supported(mvm))
+				IWL_ERR(mvm, "LMAC2 PC: 0x%x\n",
+					iwl_read_umac_prph(trans,
+						UREG_LMAC2_CURRENT_PC));
+		} else if (trans->cfg->device_family >=
+						IWL_DEVICE_FAMILY_8000) {
 			IWL_ERR(mvm,
 				"SecBoot CPU1 Status: 0x%x, CPU2 Status: 0x%x\n",
 				iwl_read_prph(trans, SB_CPU_1_STATUS),
 				iwl_read_prph(trans, SB_CPU_2_STATUS));
+		}
+
+		if (ret == -ETIMEDOUT)
+			iwl_fw_dbg_error_collect(&mvm->fwrt,
+						 FW_DBG_TRIGGER_ALIVE_TIMEOUT);
+
 		iwl_fw_set_current_image(&mvm->fwrt, old_type);
 		return ret;
 	}
diff --git a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/mvm/led.c b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/mvm/led.c
index 4348bb0..c439e9d 100644
--- a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/mvm/led.c
+++ b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/mvm/led.c
@@ -129,6 +129,9 @@ int iwl_mvm_leds_init(struct iwl_mvm *mvm)
 
 	mvm->led.name = kasprintf(GFP_KERNEL, "%s-led",
 				   wiphy_name(mvm->hw->wiphy));
+	if (!mvm->led.name)
+		return -ENOMEM;
+
 	mvm->led.brightness_set = iwl_led_brightness_set;
 	mvm->led.max_brightness = 1;
 
diff --git a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c
index ac1b4a3..dac8799 100644
--- a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c
+++ b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c
@@ -4907,6 +4907,125 @@ static int iwl_mvm_mac_get_survey(struct ieee80211_hw *hw, int idx,
 	return ret;
 }
 
+static void iwl_mvm_set_sta_rate(u32 rate_n_flags, struct rate_info *rinfo)
+{
+	switch (rate_n_flags & RATE_MCS_CHAN_WIDTH_MSK) {
+	case RATE_MCS_CHAN_WIDTH_20:
+		rinfo->bw = RATE_INFO_BW_20;
+		break;
+	case RATE_MCS_CHAN_WIDTH_40:
+		rinfo->bw = RATE_INFO_BW_40;
+		break;
+	case RATE_MCS_CHAN_WIDTH_80:
+		rinfo->bw = RATE_INFO_BW_80;
+		break;
+	case RATE_MCS_CHAN_WIDTH_160:
+		rinfo->bw = RATE_INFO_BW_160;
+		break;
+	}
+
+	if (rate_n_flags & RATE_MCS_HT_MSK) {
+		rinfo->flags |= RATE_INFO_FLAGS_MCS;
+		rinfo->mcs = u32_get_bits(rate_n_flags, RATE_HT_MCS_INDEX_MSK);
+		rinfo->nss = u32_get_bits(rate_n_flags,
+					  RATE_HT_MCS_NSS_MSK) + 1;
+		if (rate_n_flags & RATE_MCS_SGI_MSK)
+			rinfo->flags |= RATE_INFO_FLAGS_SHORT_GI;
+	} else if (rate_n_flags & RATE_MCS_VHT_MSK) {
+		rinfo->flags |= RATE_INFO_FLAGS_VHT_MCS;
+		rinfo->mcs = u32_get_bits(rate_n_flags,
+					  RATE_VHT_MCS_RATE_CODE_MSK);
+		rinfo->nss = u32_get_bits(rate_n_flags,
+					  RATE_VHT_MCS_NSS_MSK) + 1;
+		if (rate_n_flags & RATE_MCS_SGI_MSK)
+			rinfo->flags |= RATE_INFO_FLAGS_SHORT_GI;
+	} else if (rate_n_flags & RATE_MCS_HE_MSK) {
+		u32 gi_ltf = u32_get_bits(rate_n_flags,
+					  RATE_MCS_HE_GI_LTF_MSK);
+
+		rinfo->flags |= RATE_INFO_FLAGS_HE_MCS;
+		rinfo->mcs = u32_get_bits(rate_n_flags,
+					  RATE_VHT_MCS_RATE_CODE_MSK);
+		rinfo->nss = u32_get_bits(rate_n_flags,
+					  RATE_VHT_MCS_NSS_MSK) + 1;
+
+		if (rate_n_flags & RATE_MCS_HE_106T_POS) {
+			rinfo->bw = RATE_INFO_BW_HE_RU;
+			rinfo->he_ru_alloc = NL80211_RATE_INFO_HE_RU_ALLOC_106;
+		}
+
+		switch (rate_n_flags & RATE_MCS_HE_TYPE_MSK) {
+		case RATE_MCS_HE_TYPE_SU:
+		case RATE_MCS_HE_TYPE_EXT_SU:
+			if (gi_ltf == 0 || gi_ltf == 1)
+				rinfo->he_gi = NL80211_RATE_INFO_HE_GI_0_8;
+			else if (gi_ltf == 2)
+				rinfo->he_gi = NL80211_RATE_INFO_HE_GI_1_6;
+			else if (rate_n_flags & RATE_MCS_SGI_MSK)
+				rinfo->he_gi = NL80211_RATE_INFO_HE_GI_0_8;
+			else
+				rinfo->he_gi = NL80211_RATE_INFO_HE_GI_3_2;
+			break;
+		case RATE_MCS_HE_TYPE_MU:
+			if (gi_ltf == 0 || gi_ltf == 1)
+				rinfo->he_gi = NL80211_RATE_INFO_HE_GI_0_8;
+			else if (gi_ltf == 2)
+				rinfo->he_gi = NL80211_RATE_INFO_HE_GI_1_6;
+			else
+				rinfo->he_gi = NL80211_RATE_INFO_HE_GI_3_2;
+			break;
+		case RATE_MCS_HE_TYPE_TRIG:
+			if (gi_ltf == 0 || gi_ltf == 1)
+				rinfo->he_gi = NL80211_RATE_INFO_HE_GI_1_6;
+			else
+				rinfo->he_gi = NL80211_RATE_INFO_HE_GI_3_2;
+			break;
+		}
+
+		if (rate_n_flags & RATE_HE_DUAL_CARRIER_MODE)
+			rinfo->he_dcm = 1;
+	} else {
+		switch (u32_get_bits(rate_n_flags, RATE_LEGACY_RATE_MSK)) {
+		case IWL_RATE_1M_PLCP:
+			rinfo->legacy = 10;
+			break;
+		case IWL_RATE_2M_PLCP:
+			rinfo->legacy = 20;
+			break;
+		case IWL_RATE_5M_PLCP:
+			rinfo->legacy = 55;
+			break;
+		case IWL_RATE_11M_PLCP:
+			rinfo->legacy = 110;
+			break;
+		case IWL_RATE_6M_PLCP:
+			rinfo->legacy = 60;
+			break;
+		case IWL_RATE_9M_PLCP:
+			rinfo->legacy = 90;
+			break;
+		case IWL_RATE_12M_PLCP:
+			rinfo->legacy = 120;
+			break;
+		case IWL_RATE_18M_PLCP:
+			rinfo->legacy = 180;
+			break;
+		case IWL_RATE_24M_PLCP:
+			rinfo->legacy = 240;
+			break;
+		case IWL_RATE_36M_PLCP:
+			rinfo->legacy = 360;
+			break;
+		case IWL_RATE_48M_PLCP:
+			rinfo->legacy = 480;
+			break;
+		case IWL_RATE_54M_PLCP:
+			rinfo->legacy = 540;
+			break;
+		}
+	}
+}
+
 static void iwl_mvm_mac_sta_statistics(struct ieee80211_hw *hw,
 				       struct ieee80211_vif *vif,
 				       struct ieee80211_sta *sta,
@@ -4921,6 +5040,13 @@ static void iwl_mvm_mac_sta_statistics(struct ieee80211_hw *hw,
 		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_SIGNAL_AVG);
 	}
 
+	if (iwl_mvm_has_tlc_offload(mvm)) {
+		struct iwl_lq_sta_rs_fw *lq_sta = &mvmsta->lq_sta.rs_fw;
+
+		iwl_mvm_set_sta_rate(lq_sta->last_rate_n_flags, &sinfo->txrate);
+		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BITRATE);
+	}
+
 	/* if beacon filtering isn't on mac80211 does it anyway */
 	if (!(vif->driver_flags & IEEE80211_VIF_BEACON_FILTER))
 		return;
diff --git a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/mvm/power.c b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/mvm/power.c
index 20da20e..c7cb044 100644
--- a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/mvm/power.c
+++ b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/mvm/power.c
@@ -383,8 +383,6 @@ static void iwl_mvm_power_config_skip_dtim(struct iwl_mvm *mvm,
 	if (dtimper >= 10)
 		return;
 
-	/* TODO: check that multicast wake lock is off */
-
 	if (host_awake) {
 		if (iwlmvm_mod_params.power_scheme != IWL_POWER_SCHEME_LP)
 			return;
diff --git a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/mvm/sta.c b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/mvm/sta.c
index 1cdfebc..37a9e7a 100644
--- a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/mvm/sta.c
+++ b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/mvm/sta.c
@@ -1484,6 +1484,13 @@ static void iwl_mvm_realloc_queues_after_restart(struct iwl_mvm *mvm,
 					    mvm_sta->sta_id, i);
 			txq_id = iwl_mvm_tvqm_enable_txq(mvm, mvm_sta->sta_id,
 							 i, wdg);
+			/*
+			 * on failures, just set it to IWL_MVM_INVALID_QUEUE
+			 * to try again later, we have no other good way of
+			 * failing here
+			 */
+			if (txq_id < 0)
+				txq_id = IWL_MVM_INVALID_QUEUE;
 			tid_data->txq_id = txq_id;
 
 			/*
@@ -1952,30 +1959,73 @@ void iwl_mvm_dealloc_int_sta(struct iwl_mvm *mvm, struct iwl_mvm_int_sta *sta)
 	sta->sta_id = IWL_MVM_INVALID_STA;
 }
 
-static void iwl_mvm_enable_aux_snif_queue(struct iwl_mvm *mvm, u16 *queue,
+static void iwl_mvm_enable_aux_snif_queue(struct iwl_mvm *mvm, u16 queue,
 					  u8 sta_id, u8 fifo)
 {
 	unsigned int wdg_timeout = iwlmvm_mod_params.tfd_q_hang_detect ?
-					mvm->cfg->base_params->wd_timeout :
-					IWL_WATCHDOG_DISABLED;
+		mvm->cfg->base_params->wd_timeout :
+		IWL_WATCHDOG_DISABLED;
+	struct iwl_trans_txq_scd_cfg cfg = {
+		.fifo = fifo,
+		.sta_id = sta_id,
+		.tid = IWL_MAX_TID_COUNT,
+		.aggregate = false,
+		.frame_limit = IWL_FRAME_LIMIT,
+	};
 
+	WARN_ON(iwl_mvm_has_new_tx_api(mvm));
+
+	iwl_mvm_enable_txq(mvm, NULL, queue, 0, &cfg, wdg_timeout);
+}
+
+static int iwl_mvm_enable_aux_snif_queue_tvqm(struct iwl_mvm *mvm, u8 sta_id)
+{
+	unsigned int wdg_timeout = iwlmvm_mod_params.tfd_q_hang_detect ?
+		mvm->cfg->base_params->wd_timeout :
+		IWL_WATCHDOG_DISABLED;
+
+	WARN_ON(!iwl_mvm_has_new_tx_api(mvm));
+
+	return iwl_mvm_tvqm_enable_txq(mvm, sta_id, IWL_MAX_TID_COUNT,
+				       wdg_timeout);
+}
+
+static int iwl_mvm_add_int_sta_with_queue(struct iwl_mvm *mvm, int macidx,
+					  int maccolor,
+					  struct iwl_mvm_int_sta *sta,
+					  u16 *queue, int fifo)
+{
+	int ret;
+
+	/* Map queue to fifo - needs to happen before adding station */
+	if (!iwl_mvm_has_new_tx_api(mvm))
+		iwl_mvm_enable_aux_snif_queue(mvm, *queue, sta->sta_id, fifo);
+
+	ret = iwl_mvm_add_int_sta_common(mvm, sta, NULL, macidx, maccolor);
+	if (ret) {
+		if (!iwl_mvm_has_new_tx_api(mvm))
+			iwl_mvm_disable_txq(mvm, NULL, *queue,
+					    IWL_MAX_TID_COUNT, 0);
+		return ret;
+	}
+
+	/*
+	 * For 22000 firmware and on we cannot add queue to a station unknown
+	 * to firmware so enable queue here - after the station was added
+	 */
 	if (iwl_mvm_has_new_tx_api(mvm)) {
-		int tvqm_queue =
-			iwl_mvm_tvqm_enable_txq(mvm, sta_id,
-						IWL_MAX_TID_COUNT,
-						wdg_timeout);
-		*queue = tvqm_queue;
-	} else {
-		struct iwl_trans_txq_scd_cfg cfg = {
-			.fifo = fifo,
-			.sta_id = sta_id,
-			.tid = IWL_MAX_TID_COUNT,
-			.aggregate = false,
-			.frame_limit = IWL_FRAME_LIMIT,
-		};
+		int txq;
+
+		txq = iwl_mvm_enable_aux_snif_queue_tvqm(mvm, sta->sta_id);
+		if (txq < 0) {
+			iwl_mvm_rm_sta_common(mvm, sta->sta_id);
+			return txq;
+		}
 
-		iwl_mvm_enable_txq(mvm, NULL, *queue, 0, &cfg, wdg_timeout);
+		*queue = txq;
 	}
+
+	return 0;
 }
 
 int iwl_mvm_add_aux_sta(struct iwl_mvm *mvm)
@@ -1991,59 +2041,26 @@ int iwl_mvm_add_aux_sta(struct iwl_mvm *mvm)
 	if (ret)
 		return ret;
 
-	/* Map Aux queue to fifo - needs to happen before adding Aux station */
-	if (!iwl_mvm_has_new_tx_api(mvm))
-		iwl_mvm_enable_aux_snif_queue(mvm, &mvm->aux_queue,
-					      mvm->aux_sta.sta_id,
-					      IWL_MVM_TX_FIFO_MCAST);
-
-	ret = iwl_mvm_add_int_sta_common(mvm, &mvm->aux_sta, NULL,
-					 MAC_INDEX_AUX, 0);
+	ret = iwl_mvm_add_int_sta_with_queue(mvm, MAC_INDEX_AUX, 0,
+					     &mvm->aux_sta, &mvm->aux_queue,
+					     IWL_MVM_TX_FIFO_MCAST);
 	if (ret) {
 		iwl_mvm_dealloc_int_sta(mvm, &mvm->aux_sta);
 		return ret;
 	}
 
-	/*
-	 * For 22000 firmware and on we cannot add queue to a station unknown
-	 * to firmware so enable queue here - after the station was added
-	 */
-	if (iwl_mvm_has_new_tx_api(mvm))
-		iwl_mvm_enable_aux_snif_queue(mvm, &mvm->aux_queue,
-					      mvm->aux_sta.sta_id,
-					      IWL_MVM_TX_FIFO_MCAST);
-
 	return 0;
 }
 
 int iwl_mvm_add_snif_sta(struct iwl_mvm *mvm, struct ieee80211_vif *vif)
 {
 	struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
-	int ret;
 
 	lockdep_assert_held(&mvm->mutex);
 
-	/* Map snif queue to fifo - must happen before adding snif station */
-	if (!iwl_mvm_has_new_tx_api(mvm))
-		iwl_mvm_enable_aux_snif_queue(mvm, &mvm->snif_queue,
-					      mvm->snif_sta.sta_id,
-					      IWL_MVM_TX_FIFO_BE);
-
-	ret = iwl_mvm_add_int_sta_common(mvm, &mvm->snif_sta, vif->addr,
-					 mvmvif->id, 0);
-	if (ret)
-		return ret;
-
-	/*
-	 * For 22000 firmware and on we cannot add queue to a station unknown
-	 * to firmware so enable queue here - after the station was added
-	 */
-	if (iwl_mvm_has_new_tx_api(mvm))
-		iwl_mvm_enable_aux_snif_queue(mvm, &mvm->snif_queue,
-					      mvm->snif_sta.sta_id,
+	return iwl_mvm_add_int_sta_with_queue(mvm, mvmvif->id, mvmvif->color,
+					      &mvm->snif_sta, &mvm->snif_queue,
 					      IWL_MVM_TX_FIFO_BE);
-
-	return 0;
 }
 
 int iwl_mvm_rm_snif_sta(struct iwl_mvm *mvm, struct ieee80211_vif *vif)
@@ -2135,6 +2152,10 @@ int iwl_mvm_send_add_bcast_sta(struct iwl_mvm *mvm, struct ieee80211_vif *vif)
 		queue = iwl_mvm_tvqm_enable_txq(mvm, bsta->sta_id,
 						IWL_MAX_TID_COUNT,
 						wdg_timeout);
+		if (queue < 0) {
+			iwl_mvm_rm_sta_common(mvm, bsta->sta_id);
+			return queue;
+		}
 
 		if (vif->type == NL80211_IFTYPE_AP ||
 		    vif->type == NL80211_IFTYPE_ADHOC)
@@ -2309,10 +2330,8 @@ int iwl_mvm_add_mcast_sta(struct iwl_mvm *mvm, struct ieee80211_vif *vif)
 	}
 	ret = iwl_mvm_add_int_sta_common(mvm, msta, maddr,
 					 mvmvif->id, mvmvif->color);
-	if (ret) {
-		iwl_mvm_dealloc_int_sta(mvm, msta);
-		return ret;
-	}
+	if (ret)
+		goto err;
 
 	/*
 	 * Enable cab queue after the ADD_STA command is sent.
@@ -2325,6 +2344,10 @@ int iwl_mvm_add_mcast_sta(struct iwl_mvm *mvm, struct ieee80211_vif *vif)
 		int queue = iwl_mvm_tvqm_enable_txq(mvm, msta->sta_id,
 						    0,
 						    timeout);
+		if (queue < 0) {
+			ret = queue;
+			goto err;
+		}
 		mvmvif->cab_queue = queue;
 	} else if (!fw_has_api(&mvm->fw->ucode_capa,
 			       IWL_UCODE_TLV_API_STA_TYPE))
@@ -2332,6 +2355,9 @@ int iwl_mvm_add_mcast_sta(struct iwl_mvm *mvm, struct ieee80211_vif *vif)
 				   timeout);
 
 	return 0;
+err:
+	iwl_mvm_dealloc_int_sta(mvm, msta);
+	return ret;
 }
 
 static int __iwl_mvm_remove_sta_key(struct iwl_mvm *mvm, u8 sta_id,
diff --git a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/mvm/utils.c b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/mvm/utils.c
index c9cebbb..54d5485 100644
--- a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/mvm/utils.c
+++ b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/mvm/utils.c
@@ -820,7 +820,7 @@ int iwl_mvm_update_low_latency(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
 
 	iwl_mvm_bt_coex_vif_change(mvm);
 
-#ifdef CPTCFG_IWLMVM_VENDOR_CMDS
+#ifdef CPTCFG_IWLMVM_VENDOR_TCM_EVENTS
 	iwl_mvm_send_tcm_event(mvm, vif);
 #endif
 
@@ -1087,7 +1087,7 @@ static void iwl_mvm_tcm_iter(void *_data, u8 *mac, struct ieee80211_vif *vif)
 		iwl_mvm_update_low_latency(mvm, vif, low_latency,
 					   LOW_LATENCY_TRAFFIC);
 	} else {
-#ifdef CPTCFG_IWLMVM_VENDOR_CMDS
+#ifdef CPTCFG_IWLMVM_VENDOR_TCM_EVENTS
 		iwl_mvm_send_tcm_event(mvm, vif);
 #endif
 		iwl_mvm_update_quotas(mvm, false, NULL);
@@ -1109,7 +1109,7 @@ static void iwl_mvm_tcm_results(struct iwl_mvm *mvm)
 		mvm->hw, IEEE80211_IFACE_ITER_NORMAL,
 		iwl_mvm_tcm_iter, &data);
 
-#ifdef CPTCFG_IWLMVM_VENDOR_CMDS
+#ifdef CPTCFG_IWLMVM_VENDOR_TCM_EVENTS
 	/* send global only */
 	if (mvm->tcm.result.global_change && !data.any_sent)
 		iwl_mvm_send_tcm_event(mvm, NULL);
@@ -1465,12 +1465,8 @@ void iwl_mvm_get_sync_time(struct iwl_mvm *mvm, u32 *gp2, u64 *boottime)
 	}
 
 	*gp2 = iwl_mvm_get_systime(mvm);
-#if LINUX_VERSION_IS_GEQ(5,3,0)
-
-	*boottime = ktime_get_boottime_ns();
-#else
 	*boottime = ktime_get_boot_ns();
-#endif
+
 	if (!ps_disabled) {
 		mvm->ps_disabled = ps_disabled;
 		iwl_mvm_power_update_device(mvm);
diff --git a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/pcie/ctxt-info-gen3.c b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/pcie/ctxt-info-gen3.c
index 5e86783..ab48ed2 100644
--- a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/pcie/ctxt-info-gen3.c
+++ b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/pcie/ctxt-info-gen3.c
@@ -107,13 +107,9 @@ int iwl_pcie_ctxt_info_gen3_init(struct iwl_trans *trans,
 
 	/* allocate ucode sections in dram and set addresses */
 	ret = iwl_pcie_init_fw_sec(trans, fw, &prph_scratch->dram);
-	if (ret) {
-		dma_free_coherent(trans->dev,
-				  sizeof(*prph_scratch),
-				  prph_scratch,
-				  trans_pcie->prph_scratch_dma_addr);
-		return ret;
-	}
+	if (ret)
+		goto err_free_prph_scratch;
+
 
 	/* Allocate prph information
 	 * currently we don't assign to the prph info anything, but it would get
@@ -121,16 +117,20 @@ int iwl_pcie_ctxt_info_gen3_init(struct iwl_trans *trans,
 	prph_info = dma_alloc_coherent(trans->dev, sizeof(*prph_info),
 				       &trans_pcie->prph_info_dma_addr,
 				       GFP_KERNEL);
-	if (!prph_info)
-		return -ENOMEM;
+	if (!prph_info) {
+		ret = -ENOMEM;
+		goto err_free_prph_scratch;
+	}
 
 	/* Allocate context info */
 	ctxt_info_gen3 = dma_alloc_coherent(trans->dev,
 					    sizeof(*ctxt_info_gen3),
 					    &trans_pcie->ctxt_info_dma_addr,
 					    GFP_KERNEL);
-	if (!ctxt_info_gen3)
-		return -ENOMEM;
+	if (!ctxt_info_gen3) {
+		ret = -ENOMEM;
+		goto err_free_prph_info;
+	}
 
 	ctxt_info_gen3->prph_info_base_addr =
 		cpu_to_le64(trans_pcie->prph_info_dma_addr);
@@ -186,6 +186,20 @@ int iwl_pcie_ctxt_info_gen3_init(struct iwl_trans *trans,
 		iwl_set_bit(trans, CSR_GP_CNTRL, CSR_AUTO_FUNC_INIT);
 
 	return 0;
+
+err_free_prph_info:
+	dma_free_coherent(trans->dev,
+			  sizeof(*prph_info),
+			prph_info,
+			trans_pcie->prph_info_dma_addr);
+
+err_free_prph_scratch:
+	dma_free_coherent(trans->dev,
+			  sizeof(*prph_scratch),
+			prph_scratch,
+			trans_pcie->prph_scratch_dma_addr);
+	return ret;
+
 }
 
 void iwl_pcie_ctxt_info_gen3_free(struct iwl_trans *trans)
diff --git a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/pcie/drv.c b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/pcie/drv.c
index 30a35f4..4c12b30 100644
--- a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/pcie/drv.c
+++ b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/pcie/drv.c
@@ -540,6 +540,7 @@ static const struct pci_device_id iwl_hw_card_ids[] = {
 	{IWL_PCI_DEVICE(0x02F0, 0x40A4, iwl9462_2ac_cfg_qu_b0_jf_b0)},
 	{IWL_PCI_DEVICE(0x02F0, 0x4234, iwl9560_2ac_cfg_qu_b0_jf_b0)},
 	{IWL_PCI_DEVICE(0x02F0, 0x42A4, iwl9462_2ac_cfg_qu_b0_jf_b0)},
+
 	{IWL_PCI_DEVICE(0x06F0, 0x0030, iwl9560_2ac_160_cfg_quz_a0_jf_b0_soc)},
 	{IWL_PCI_DEVICE(0x06F0, 0x0034, iwl9560_2ac_cfg_quz_a0_jf_b0_soc)},
 	{IWL_PCI_DEVICE(0x06F0, 0x0038, iwl9560_2ac_160_cfg_quz_a0_jf_b0_soc)},
@@ -618,59 +619,61 @@ static const struct pci_device_id iwl_hw_card_ids[] = {
 	{IWL_PCI_DEVICE(0x271B, 0x0210, iwl9160_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x271B, 0x0214, iwl9260_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x271C, 0x0214, iwl9260_2ac_cfg)},
-	{IWL_PCI_DEVICE(0x2720, 0x0034, iwl9560_2ac_160_cfg)},
-	{IWL_PCI_DEVICE(0x2720, 0x0038, iwl9560_2ac_160_cfg)},
-	{IWL_PCI_DEVICE(0x2720, 0x003C, iwl9560_2ac_160_cfg)},
-	{IWL_PCI_DEVICE(0x2720, 0x0060, iwl9461_2ac_cfg_soc)},
-	{IWL_PCI_DEVICE(0x2720, 0x0064, iwl9461_2ac_cfg_soc)},
-	{IWL_PCI_DEVICE(0x2720, 0x00A0, iwl9462_2ac_cfg_soc)},
-	{IWL_PCI_DEVICE(0x2720, 0x00A4, iwl9462_2ac_cfg_soc)},
-	{IWL_PCI_DEVICE(0x2720, 0x0230, iwl9560_2ac_cfg)},
-	{IWL_PCI_DEVICE(0x2720, 0x0234, iwl9560_2ac_cfg)},
-	{IWL_PCI_DEVICE(0x2720, 0x0238, iwl9560_2ac_cfg)},
-	{IWL_PCI_DEVICE(0x2720, 0x023C, iwl9560_2ac_cfg)},
-	{IWL_PCI_DEVICE(0x2720, 0x0260, iwl9461_2ac_cfg_soc)},
-	{IWL_PCI_DEVICE(0x2720, 0x0264, iwl9461_2ac_cfg_soc)},
-	{IWL_PCI_DEVICE(0x2720, 0x02A0, iwl9462_2ac_cfg_soc)},
-	{IWL_PCI_DEVICE(0x2720, 0x02A4, iwl9462_2ac_cfg_soc)},
-	{IWL_PCI_DEVICE(0x2720, 0x1010, iwl9260_2ac_cfg)},
-	{IWL_PCI_DEVICE(0x2720, 0x1030, iwl9560_2ac_cfg_soc)},
-	{IWL_PCI_DEVICE(0x2720, 0x1210, iwl9260_2ac_cfg)},
-	{IWL_PCI_DEVICE(0x2720, 0x1551, iwl9560_killer_s_2ac_cfg_soc)},
-	{IWL_PCI_DEVICE(0x2720, 0x1552, iwl9560_killer_2ac_cfg_soc)},
-	{IWL_PCI_DEVICE(0x2720, 0x2030, iwl9560_2ac_160_cfg_soc)},
-	{IWL_PCI_DEVICE(0x2720, 0x2034, iwl9560_2ac_160_cfg_soc)},
-	{IWL_PCI_DEVICE(0x2720, 0x4030, iwl9560_2ac_160_cfg)},
-	{IWL_PCI_DEVICE(0x2720, 0x4034, iwl9560_2ac_160_cfg_soc)},
-	{IWL_PCI_DEVICE(0x2720, 0x40A4, iwl9462_2ac_cfg_soc)},
-	{IWL_PCI_DEVICE(0x2720, 0x4234, iwl9560_2ac_cfg_soc)},
-	{IWL_PCI_DEVICE(0x2720, 0x42A4, iwl9462_2ac_cfg_soc)},
-	{IWL_PCI_DEVICE(0x30DC, 0x0030, iwl9560_2ac_160_cfg_qu_b0_jf_b0)},
-	{IWL_PCI_DEVICE(0x30DC, 0x0034, iwl9560_2ac_cfg_qu_b0_jf_b0)},
-	{IWL_PCI_DEVICE(0x30DC, 0x0038, iwl9560_2ac_160_cfg_qu_b0_jf_b0)},
-	{IWL_PCI_DEVICE(0x30DC, 0x003C, iwl9560_2ac_160_cfg_qu_b0_jf_b0)},
-	{IWL_PCI_DEVICE(0x30DC, 0x0060, iwl9461_2ac_cfg_qu_b0_jf_b0)},
-	{IWL_PCI_DEVICE(0x30DC, 0x0064, iwl9461_2ac_cfg_qu_b0_jf_b0)},
-	{IWL_PCI_DEVICE(0x30DC, 0x00A0, iwl9462_2ac_cfg_qu_b0_jf_b0)},
-	{IWL_PCI_DEVICE(0x30DC, 0x00A4, iwl9462_2ac_cfg_qu_b0_jf_b0)},
-	{IWL_PCI_DEVICE(0x30DC, 0x0230, iwl9560_2ac_cfg_qu_b0_jf_b0)},
-	{IWL_PCI_DEVICE(0x30DC, 0x0234, iwl9560_2ac_cfg_qu_b0_jf_b0)},
-	{IWL_PCI_DEVICE(0x30DC, 0x0238, iwl9560_2ac_cfg_qu_b0_jf_b0)},
-	{IWL_PCI_DEVICE(0x30DC, 0x023C, iwl9560_2ac_cfg_qu_b0_jf_b0)},
-	{IWL_PCI_DEVICE(0x30DC, 0x0260, iwl9461_2ac_cfg_qu_b0_jf_b0)},
-	{IWL_PCI_DEVICE(0x30DC, 0x0264, iwl9461_2ac_cfg_qu_b0_jf_b0)},
-	{IWL_PCI_DEVICE(0x30DC, 0x02A0, iwl9462_2ac_cfg_qu_b0_jf_b0)},
-	{IWL_PCI_DEVICE(0x30DC, 0x02A4, iwl9462_2ac_cfg_qu_b0_jf_b0)},
-	{IWL_PCI_DEVICE(0x30DC, 0x1030, iwl9560_2ac_cfg_qu_b0_jf_b0)},
-	{IWL_PCI_DEVICE(0x30DC, 0x1551, killer1550s_2ac_cfg_qu_b0_jf_b0)},
-	{IWL_PCI_DEVICE(0x30DC, 0x1552, killer1550i_2ac_cfg_qu_b0_jf_b0)},
-	{IWL_PCI_DEVICE(0x30DC, 0x2030, iwl9560_2ac_160_cfg_qu_b0_jf_b0)},
-	{IWL_PCI_DEVICE(0x30DC, 0x2034, iwl9560_2ac_160_cfg_qu_b0_jf_b0)},
-	{IWL_PCI_DEVICE(0x30DC, 0x4030, iwl9560_2ac_160_cfg_qu_b0_jf_b0)},
-	{IWL_PCI_DEVICE(0x30DC, 0x4034, iwl9560_2ac_160_cfg_qu_b0_jf_b0)},
-	{IWL_PCI_DEVICE(0x30DC, 0x40A4, iwl9462_2ac_cfg_qu_b0_jf_b0)},
-	{IWL_PCI_DEVICE(0x30DC, 0x4234, iwl9560_2ac_cfg_qu_b0_jf_b0)},
-	{IWL_PCI_DEVICE(0x30DC, 0x42A4, iwl9462_2ac_cfg_qu_b0_jf_b0)},
+
+	{IWL_PCI_DEVICE(0x2720, 0x0034, iwl9560_2ac_cfg_qu_b0_jf_b0)},
+	{IWL_PCI_DEVICE(0x2720, 0x0038, iwl9560_2ac_160_cfg_qu_b0_jf_b0)},
+	{IWL_PCI_DEVICE(0x2720, 0x003C, iwl9560_2ac_160_cfg_qu_b0_jf_b0)},
+	{IWL_PCI_DEVICE(0x2720, 0x0060, iwl9461_2ac_cfg_qu_b0_jf_b0)},
+	{IWL_PCI_DEVICE(0x2720, 0x0064, iwl9461_2ac_cfg_qu_b0_jf_b0)},
+	{IWL_PCI_DEVICE(0x2720, 0x00A0, iwl9462_2ac_cfg_qu_b0_jf_b0)},
+	{IWL_PCI_DEVICE(0x2720, 0x00A4, iwl9462_2ac_cfg_qu_b0_jf_b0)},
+	{IWL_PCI_DEVICE(0x2720, 0x0230, iwl9560_2ac_cfg_qu_b0_jf_b0)},
+	{IWL_PCI_DEVICE(0x2720, 0x0234, iwl9560_2ac_cfg_qu_b0_jf_b0)},
+	{IWL_PCI_DEVICE(0x2720, 0x0238, iwl9560_2ac_cfg_qu_b0_jf_b0)},
+	{IWL_PCI_DEVICE(0x2720, 0x023C, iwl9560_2ac_cfg_qu_b0_jf_b0)},
+	{IWL_PCI_DEVICE(0x2720, 0x0260, iwl9461_2ac_cfg_qu_b0_jf_b0)},
+	{IWL_PCI_DEVICE(0x2720, 0x0264, iwl9461_2ac_cfg_qu_b0_jf_b0)},
+	{IWL_PCI_DEVICE(0x2720, 0x02A0, iwl9462_2ac_cfg_qu_b0_jf_b0)},
+	{IWL_PCI_DEVICE(0x2720, 0x02A4, iwl9462_2ac_cfg_qu_b0_jf_b0)},
+	{IWL_PCI_DEVICE(0x2720, 0x1030, iwl9560_2ac_cfg_qu_b0_jf_b0)},
+	{IWL_PCI_DEVICE(0x2720, 0x1551, killer1550s_2ac_cfg_qu_b0_jf_b0)},
+	{IWL_PCI_DEVICE(0x2720, 0x1552, killer1550i_2ac_cfg_qu_b0_jf_b0)},
+	{IWL_PCI_DEVICE(0x2720, 0x2030, iwl9560_2ac_160_cfg_qu_b0_jf_b0)},
+	{IWL_PCI_DEVICE(0x2720, 0x2034, iwl9560_2ac_160_cfg_qu_b0_jf_b0)},
+	{IWL_PCI_DEVICE(0x2720, 0x4030, iwl9560_2ac_160_cfg_qu_b0_jf_b0)},
+	{IWL_PCI_DEVICE(0x2720, 0x4034, iwl9560_2ac_160_cfg_qu_b0_jf_b0)},
+	{IWL_PCI_DEVICE(0x2720, 0x40A4, iwl9462_2ac_cfg_qu_b0_jf_b0)},
+	{IWL_PCI_DEVICE(0x2720, 0x4234, iwl9560_2ac_cfg_qu_b0_jf_b0)},
+	{IWL_PCI_DEVICE(0x2720, 0x42A4, iwl9462_2ac_cfg_qu_b0_jf_b0)},
+
+	{IWL_PCI_DEVICE(0x30DC, 0x0030, iwl9560_2ac_160_cfg_soc)},
+	{IWL_PCI_DEVICE(0x30DC, 0x0034, iwl9560_2ac_cfg_soc)},
+	{IWL_PCI_DEVICE(0x30DC, 0x0038, iwl9560_2ac_160_cfg_soc)},
+	{IWL_PCI_DEVICE(0x30DC, 0x003C, iwl9560_2ac_160_cfg_soc)},
+	{IWL_PCI_DEVICE(0x30DC, 0x0060, iwl9460_2ac_cfg_soc)},
+	{IWL_PCI_DEVICE(0x30DC, 0x0064, iwl9461_2ac_cfg_soc)},
+	{IWL_PCI_DEVICE(0x30DC, 0x00A0, iwl9462_2ac_cfg_soc)},
+	{IWL_PCI_DEVICE(0x30DC, 0x00A4, iwl9462_2ac_cfg_soc)},
+	{IWL_PCI_DEVICE(0x30DC, 0x0230, iwl9560_2ac_cfg_soc)},
+	{IWL_PCI_DEVICE(0x30DC, 0x0234, iwl9560_2ac_cfg_soc)},
+	{IWL_PCI_DEVICE(0x30DC, 0x0238, iwl9560_2ac_cfg_soc)},
+	{IWL_PCI_DEVICE(0x30DC, 0x023C, iwl9560_2ac_cfg_soc)},
+	{IWL_PCI_DEVICE(0x30DC, 0x0260, iwl9461_2ac_cfg_soc)},
+	{IWL_PCI_DEVICE(0x30DC, 0x0264, iwl9461_2ac_cfg_soc)},
+	{IWL_PCI_DEVICE(0x30DC, 0x02A0, iwl9462_2ac_cfg_soc)},
+	{IWL_PCI_DEVICE(0x30DC, 0x02A4, iwl9462_2ac_cfg_soc)},
+	{IWL_PCI_DEVICE(0x30DC, 0x1010, iwl9260_2ac_cfg)},
+	{IWL_PCI_DEVICE(0x30DC, 0x1030, iwl9560_2ac_cfg_soc)},
+	{IWL_PCI_DEVICE(0x30DC, 0x1210, iwl9260_2ac_cfg)},
+	{IWL_PCI_DEVICE(0x30DC, 0x1551, iwl9560_killer_s_2ac_cfg_soc)},
+	{IWL_PCI_DEVICE(0x30DC, 0x1552, iwl9560_killer_2ac_cfg_soc)},
+	{IWL_PCI_DEVICE(0x30DC, 0x2030, iwl9560_2ac_160_cfg_soc)},
+	{IWL_PCI_DEVICE(0x30DC, 0x2034, iwl9560_2ac_160_cfg_soc)},
+	{IWL_PCI_DEVICE(0x30DC, 0x4030, iwl9560_2ac_160_cfg_soc)},
+	{IWL_PCI_DEVICE(0x30DC, 0x4034, iwl9560_2ac_160_cfg_soc)},
+	{IWL_PCI_DEVICE(0x30DC, 0x40A4, iwl9462_2ac_cfg_soc)},
+	{IWL_PCI_DEVICE(0x30DC, 0x4234, iwl9560_2ac_cfg_soc)},
+	{IWL_PCI_DEVICE(0x30DC, 0x42A4, iwl9462_2ac_cfg_soc)},
 
 	{IWL_PCI_DEVICE(0x31DC, 0x0030, iwl9560_2ac_160_cfg_shared_clk)},
 	{IWL_PCI_DEVICE(0x31DC, 0x0034, iwl9560_2ac_cfg_shared_clk)},
@@ -726,6 +729,7 @@ static const struct pci_device_id iwl_hw_card_ids[] = {
 	{IWL_PCI_DEVICE(0x34F0, 0x40A4, iwl9462_2ac_cfg_qu_b0_jf_b0)},
 	{IWL_PCI_DEVICE(0x34F0, 0x4234, iwl9560_2ac_cfg_qu_b0_jf_b0)},
 	{IWL_PCI_DEVICE(0x34F0, 0x42A4, iwl9462_2ac_cfg_qu_b0_jf_b0)},
+
 	{IWL_PCI_DEVICE(0x3DF0, 0x0030, iwl9560_2ac_160_cfg_qu_b0_jf_b0)},
 	{IWL_PCI_DEVICE(0x3DF0, 0x0034, iwl9560_2ac_cfg_qu_b0_jf_b0)},
 	{IWL_PCI_DEVICE(0x3DF0, 0x0038, iwl9560_2ac_160_cfg_qu_b0_jf_b0)},
@@ -906,11 +910,13 @@ static const struct pci_device_id iwl_hw_card_ids[] = {
 	{IWL_PCI_DEVICE(0x06F0, 0x4244, iwl_ax101_cfg_quz_hr)},
 	{IWL_PCI_DEVICE(0x2720, 0x0000, iwl_ax101_cfg_qu_hr)},
 	{IWL_PCI_DEVICE(0x2720, 0x0040, iwl_ax101_cfg_qu_hr)},
+	{IWL_PCI_DEVICE(0x2720, 0x0044, iwl_ax101_cfg_qu_hr)},
 	{IWL_PCI_DEVICE(0x2720, 0x0070, iwl_ax201_cfg_qu_hr)},
 	{IWL_PCI_DEVICE(0x2720, 0x0074, iwl_ax201_cfg_qu_hr)},
 	{IWL_PCI_DEVICE(0x2720, 0x0078, iwl_ax201_cfg_qu_hr)},
 	{IWL_PCI_DEVICE(0x2720, 0x007C, iwl_ax201_cfg_qu_hr)},
 	{IWL_PCI_DEVICE(0x2720, 0x0090, iwl22000_2ac_cfg_hr_cdb)},
+	{IWL_PCI_DEVICE(0x2720, 0x0244, iwl_ax101_cfg_qu_hr)},
 	{IWL_PCI_DEVICE(0x2720, 0x0310, iwl_ax201_cfg_qu_hr)},
 	{IWL_PCI_DEVICE(0x2720, 0x0A10, iwl_ax201_cfg_qu_hr)},
 	{IWL_PCI_DEVICE(0x2720, 0x1080, iwl_ax101_cfg_qu_hr)},
@@ -919,10 +925,12 @@ static const struct pci_device_id iwl_hw_card_ids[] = {
 	{IWL_PCI_DEVICE(0x2720, 0x2074, iwl_ax201_cfg_qu_hr)},
 	{IWL_PCI_DEVICE(0x2720, 0x4070, iwl_ax201_cfg_qu_hr)},
 	{IWL_PCI_DEVICE(0x2720, 0x4244, iwl_ax101_cfg_qu_hr)},
+	{IWL_PCI_DEVICE(0x34F0, 0x0044, iwl_ax101_cfg_qu_hr)},
 	{IWL_PCI_DEVICE(0x34F0, 0x0070, iwl_ax201_cfg_qu_hr)},
 	{IWL_PCI_DEVICE(0x34F0, 0x0074, iwl_ax201_cfg_qu_hr)},
 	{IWL_PCI_DEVICE(0x34F0, 0x0078, iwl_ax201_cfg_qu_hr)},
 	{IWL_PCI_DEVICE(0x34F0, 0x007C, iwl_ax201_cfg_qu_hr)},
+	{IWL_PCI_DEVICE(0x34F0, 0x0244, iwl_ax101_cfg_qu_hr)},
 	{IWL_PCI_DEVICE(0x34F0, 0x0310, iwl_ax201_cfg_qu_hr)},
 	{IWL_PCI_DEVICE(0x34F0, 0x1651, killer1650s_2ax_cfg_qu_b0_hr_b0)},
 	{IWL_PCI_DEVICE(0x34F0, 0x1652, killer1650i_2ax_cfg_qu_b0_hr_b0)},
diff --git a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/pcie/trans-gen2.c b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/pcie/trans-gen2.c
index c099ad8..28d1fc9 100644
--- a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/pcie/trans-gen2.c
+++ b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/pcie/trans-gen2.c
@@ -57,6 +57,25 @@
 #include "internal.h"
 #include "fw/dbg.h"
 
+static int iwl_pcie_gen2_force_power_gating(struct iwl_trans *trans)
+{
+	iwl_set_bits_prph(trans, HPM_HIPM_GEN_CFG,
+			  HPM_HIPM_GEN_CFG_CR_FORCE_ACTIVE);
+	udelay(20);
+	iwl_set_bits_prph(trans, HPM_HIPM_GEN_CFG,
+			  HPM_HIPM_GEN_CFG_CR_PG_EN |
+			  HPM_HIPM_GEN_CFG_CR_SLP_EN);
+	udelay(20);
+	iwl_clear_bits_prph(trans, HPM_HIPM_GEN_CFG,
+			    HPM_HIPM_GEN_CFG_CR_FORCE_ACTIVE);
+
+	iwl_trans_sw_reset(trans);
+	iwl_clear_bit(trans, CSR_GP_CNTRL,
+		      BIT(trans->cfg->csr->flag_init_done));
+
+	return 0;
+}
+
 /*
  * Start up NIC's basic functionality after it has been reset
  * (e.g. after platform boot, or shutdown via iwl_pcie_apm_stop())
@@ -92,6 +111,13 @@ int iwl_pcie_gen2_apm_init(struct iwl_trans *trans)
 
 	iwl_pcie_apm_config(trans);
 
+	if (trans->cfg->device_family == IWL_DEVICE_FAMILY_22000 &&
+	    trans->cfg->integrated) {
+		ret = iwl_pcie_gen2_force_power_gating(trans);
+		if (ret)
+			return ret;
+	}
+
 	ret = iwl_finish_nic_init(trans);
 	if (ret)
 		return ret;
diff --git a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/pcie/trans.c b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/pcie/trans.c
index 664ab42..2e43128 100644
--- a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/pcie/trans.c
+++ b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/pcie/trans.c
@@ -3450,6 +3450,15 @@ struct iwl_trans *iwl_trans_pcie_alloc(struct pci_dev *pdev,
 	spin_lock_init(&trans_pcie->reg_lock);
 	mutex_init(&trans_pcie->mutex);
 	init_waitqueue_head(&trans_pcie->ucode_write_waitq);
+
+	trans_pcie->rba.alloc_wq = alloc_workqueue("rb_allocator",
+						   WQ_HIGHPRI | WQ_UNBOUND, 1);
+	if (!trans_pcie->rba.alloc_wq) {
+		ret = -ENOMEM;
+		goto out_free_trans;
+	}
+	INIT_WORK(&trans_pcie->rba.rx_alloc, iwl_pcie_rx_allocator_work);
+
 	trans_pcie->tso_hdr_page = alloc_percpu(struct iwl_tso_hdr_page);
 	if (!trans_pcie->tso_hdr_page) {
 		ret = -ENOMEM;
@@ -3696,10 +3705,6 @@ struct iwl_trans *iwl_trans_pcie_alloc(struct pci_dev *pdev,
 		trans_pcie->inta_mask = CSR_INI_SET_MASK;
 	 }
 
-	trans_pcie->rba.alloc_wq = alloc_workqueue("rb_allocator",
-						   WQ_HIGHPRI | WQ_UNBOUND, 1);
-	INIT_WORK(&trans_pcie->rba.rx_alloc, iwl_pcie_rx_allocator_work);
-
 #ifdef CPTCFG_IWLWIFI_DEBUGFS
 	trans_pcie->fw_mon_data.state = IWL_FW_MON_DBGFS_STATE_CLOSED;
 	mutex_init(&trans_pcie->fw_mon_data.mutex);
@@ -3711,6 +3716,8 @@ out_free_ict:
 	iwl_pcie_free_ict(trans);
 out_no_pci:
 	free_percpu(trans_pcie->tso_hdr_page);
+	destroy_workqueue(trans_pcie->rba.alloc_wq);
+out_free_trans:
 	iwl_trans_free(trans);
 	return ERR_PTR(ret);
 }
diff --git a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/pcie/tx-gen2.c b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/pcie/tx-gen2.c
index 57cfcce..5bf79a7 100644
--- a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/pcie/tx-gen2.c
+++ b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/pcie/tx-gen2.c
@@ -251,27 +251,23 @@ static int iwl_pcie_gen2_build_amsdu(struct iwl_trans *trans,
 	struct ieee80211_hdr *hdr = (void *)skb->data;
 	unsigned int snap_ip_tcp_hdrlen, ip_hdrlen, total_len, hdr_room;
 	unsigned int mss = skb_shinfo(skb)->gso_size;
-	u16 length, iv_len, amsdu_pad;
+	u16 length, amsdu_pad;
 	u8 *start_hdr;
 	struct iwl_tso_hdr_page *hdr_page;
 	struct page **page_ptr;
 	struct tso_t tso;
 
-	/* if the packet is protected, then it must be CCMP or GCMP */
-	iv_len = ieee80211_has_protected(hdr->frame_control) ?
-		IEEE80211_CCMP_HDR_LEN : 0;
-
 	trace_iwlwifi_dev_tx(trans->dev, skb, tfd, sizeof(*tfd),
 			     &dev_cmd->hdr, start_len, 0);
 
 	ip_hdrlen = skb_transport_header(skb) - skb_network_header(skb);
 	snap_ip_tcp_hdrlen = 8 + ip_hdrlen + tcp_hdrlen(skb);
-	total_len = skb->len - snap_ip_tcp_hdrlen - hdr_len - iv_len;
+	total_len = skb->len - snap_ip_tcp_hdrlen - hdr_len;
 	amsdu_pad = 0;
 
 	/* total amount of header we may need for this A-MSDU */
 	hdr_room = DIV_ROUND_UP(total_len, mss) *
-		(3 + snap_ip_tcp_hdrlen + sizeof(struct ethhdr)) + iv_len;
+		(3 + snap_ip_tcp_hdrlen + sizeof(struct ethhdr));
 
 	/* Our device supports 9 segments at most, it will fit in 1 page */
 	hdr_page = get_page_hdr(trans, hdr_room);
@@ -282,14 +278,12 @@ static int iwl_pcie_gen2_build_amsdu(struct iwl_trans *trans,
 	start_hdr = hdr_page->pos;
 	page_ptr = (void *)((u8 *)skb->cb + trans_pcie->page_offs);
 	*page_ptr = hdr_page->page;
-	memcpy(hdr_page->pos, skb->data + hdr_len, iv_len);
-	hdr_page->pos += iv_len;
 
 	/*
-	 * Pull the ieee80211 header + IV to be able to use TSO core,
+	 * Pull the ieee80211 header to be able to use TSO core,
 	 * we will restore it for the tx_status flow.
 	 */
-	skb_pull(skb, hdr_len + iv_len);
+	skb_pull(skb, hdr_len);
 
 	/*
 	 * Remove the length of all the headers that we don't actually
@@ -339,7 +333,8 @@ static int iwl_pcie_gen2_build_amsdu(struct iwl_trans *trans,
 			goto out_err;
 		}
 		iwl_pcie_gen2_set_tb(trans, tfd, tb_phys, tb_len);
-		trace_iwlwifi_dev_tx_tb(trans->dev, skb, start_hdr, tb_len);
+		trace_iwlwifi_dev_tx_tb(trans->dev, skb, start_hdr,
+					tb_phys, tb_len);
 		/* add this subframe's headers' length to the tx_cmd */
 		le16_add_cpu(&tx_cmd->len, hdr_page->pos - subf_hdrs_start);
 
@@ -357,15 +352,15 @@ static int iwl_pcie_gen2_build_amsdu(struct iwl_trans *trans,
 			}
 			iwl_pcie_gen2_set_tb(trans, tfd, tb_phys, tb_len);
 			trace_iwlwifi_dev_tx_tb(trans->dev, skb, tso.data,
-						tb_len);
+						tb_phys, tb_len);
 
 			data_left -= tb_len;
 			tso_build_data(skb, &tso, tb_len);
 		}
 	}
 
-	/* re -add the WiFi header and IV */
-	skb_push(skb, hdr_len + iv_len);
+	/* re -add the WiFi header */
+	skb_push(skb, hdr_len);
 
 	return 0;
 
@@ -447,9 +442,8 @@ static int iwl_pcie_gen2_tx_add_frags(struct iwl_trans *trans,
 			return -ENOMEM;
 		tb_idx = iwl_pcie_gen2_set_tb(trans, tfd, tb_phys,
 					      skb_frag_size(frag));
-		trace_iwlwifi_dev_tx_tb(trans->dev, skb,
-					skb_frag_address(frag),
-					skb_frag_size(frag));
+		trace_iwlwifi_dev_tx_tb(trans->dev, skb, skb_frag_address(frag),
+					tb_phys, skb_frag_size(frag));
 		if (tb_idx < 0)
 			return tb_idx;
 
@@ -515,9 +509,8 @@ iwl_tfh_tfd *iwl_pcie_gen2_build_tx(struct iwl_trans *trans,
 		if (unlikely(dma_mapping_error(trans->dev, tb_phys)))
 			goto out_err;
 		iwl_pcie_gen2_set_tb(trans, tfd, tb_phys, tb2_len);
-		trace_iwlwifi_dev_tx_tb(trans->dev, skb,
-					skb->data + hdr_len,
-					tb2_len);
+		trace_iwlwifi_dev_tx_tb(trans->dev, skb, skb->data + hdr_len,
+					tb_phys, tb2_len);
 	}
 
 	if (iwl_pcie_gen2_tx_add_frags(trans, skb, tfd, out_meta))
@@ -529,9 +522,8 @@ iwl_tfh_tfd *iwl_pcie_gen2_build_tx(struct iwl_trans *trans,
 		if (unlikely(dma_mapping_error(trans->dev, tb_phys)))
 			goto out_err;
 		iwl_pcie_gen2_set_tb(trans, tfd, tb_phys, skb_headlen(frag));
-		trace_iwlwifi_dev_tx_tb(trans->dev, skb,
-					frag->data,
-					skb_headlen(frag));
+		trace_iwlwifi_dev_tx_tb(trans->dev, skb, frag->data,
+					tb_phys, skb_headlen(frag));
 		if (iwl_pcie_gen2_tx_add_frags(trans, frag, tfd, out_meta))
 			goto out_err;
 	}
diff --git a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/pcie/tx.c b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/pcie/tx.c
index 3aa6821..3d409c3 100644
--- a/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/pcie/tx.c
+++ b/iwlwifi-stack-dev/drivers/net/wireless/intel/iwlwifi/pcie/tx.c
@@ -2032,9 +2032,8 @@ static int iwl_fill_data_tbs(struct iwl_trans *trans, struct sk_buff *skb,
 						    head_tb_len, DMA_TO_DEVICE);
 		if (unlikely(dma_mapping_error(trans->dev, tb_phys)))
 			return -EINVAL;
-		trace_iwlwifi_dev_tx_tb(trans->dev, skb,
-					skb->data + hdr_len,
-					head_tb_len);
+		trace_iwlwifi_dev_tx_tb(trans->dev, skb, skb->data + hdr_len,
+					tb_phys, head_tb_len);
 		iwl_pcie_txq_build_tfd(trans, txq, tb_phys, head_tb_len, false);
 	}
 
@@ -2052,9 +2051,8 @@ static int iwl_fill_data_tbs(struct iwl_trans *trans, struct sk_buff *skb,
 
 		if (unlikely(dma_mapping_error(trans->dev, tb_phys)))
 			return -EINVAL;
-		trace_iwlwifi_dev_tx_tb(trans->dev, skb,
-					skb_frag_address(frag),
-					skb_frag_size(frag));
+		trace_iwlwifi_dev_tx_tb(trans->dev, skb, skb_frag_address(frag),
+					tb_phys, skb_frag_size(frag));
 		tb_idx = iwl_pcie_txq_build_tfd(trans, txq, tb_phys,
 						skb_frag_size(frag), false);
 		if (tb_idx < 0)
@@ -2235,7 +2233,7 @@ static int iwl_fill_data_tbs_amsdu(struct iwl_trans *trans, struct sk_buff *skb,
 		iwl_pcie_txq_build_tfd(trans, txq, hdr_tb_phys,
 				       hdr_tb_len, false);
 		trace_iwlwifi_dev_tx_tb(trans->dev, skb, start_hdr,
-					hdr_tb_len);
+					hdr_tb_phys, hdr_tb_len);
 		/* add this subframe's headers' length to the tx_cmd */
 		le16_add_cpu(&tx_cmd->len, hdr_page->pos - subf_hdrs_start);
 
@@ -2261,7 +2259,7 @@ static int iwl_fill_data_tbs_amsdu(struct iwl_trans *trans, struct sk_buff *skb,
 			iwl_pcie_txq_build_tfd(trans, txq, tb_phys,
 					       size, false);
 			trace_iwlwifi_dev_tx_tb(trans->dev, skb, tso.data,
-						size);
+						tb_phys, size);
 
 			data_left -= size;
 			tso_build_data(skb, &tso, size);
diff --git a/iwlwifi-stack-dev/include/crypto/arc4.h b/iwlwifi-stack-dev/include/crypto/arc4.h
new file mode 100644
index 0000000..30e582d
--- /dev/null
+++ b/iwlwifi-stack-dev/include/crypto/arc4.h
@@ -0,0 +1,10 @@
+/* Automatically created during backport process */
+#ifndef CPTCFG_BPAUTO_BUILD_CRYPTO_LIB_ARC4
+#include_next <crypto/arc4.h>
+#else
+#undef arc4_setkey
+#define arc4_setkey LINUX_BACKPORT(arc4_setkey)
+#undef arc4_crypt
+#define arc4_crypt LINUX_BACKPORT(arc4_crypt)
+#include <crypto/backport-arc4.h>
+#endif /* CPTCFG_BPAUTO_BUILD_CRYPTO_LIB_ARC4 */
diff --git a/iwlwifi-stack-dev/include/crypto/backport-arc4.h b/iwlwifi-stack-dev/include/crypto/backport-arc4.h
new file mode 100644
index 0000000..f3c22fe
--- /dev/null
+++ b/iwlwifi-stack-dev/include/crypto/backport-arc4.h
@@ -0,0 +1,23 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Common values for ARC4 Cipher Algorithm
+ */
+
+#ifndef _CRYPTO_ARC4_H
+#define _CRYPTO_ARC4_H
+
+#include <linux/types.h>
+
+#define ARC4_MIN_KEY_SIZE	1
+#define ARC4_MAX_KEY_SIZE	256
+#define ARC4_BLOCK_SIZE		1
+
+struct arc4_ctx {
+	u32 S[256];
+	u32 x, y;
+};
+
+int arc4_setkey(struct arc4_ctx *ctx, const u8 *in_key, unsigned int key_len);
+void arc4_crypt(struct arc4_ctx *ctx, u8 *out, const u8 *in, unsigned int len);
+
+#endif /* _CRYPTO_ARC4_H */
diff --git a/iwlwifi-stack-dev/include/net/fq.h b/iwlwifi-stack-dev/include/net/fq.h
index ac944a6..8f18ff5 100644
--- a/iwlwifi-stack-dev/include/net/fq.h
+++ b/iwlwifi-stack-dev/include/net/fq.h
@@ -70,7 +70,15 @@ struct fq {
 	struct list_head backlogs;
 	spinlock_t lock;
 	u32 flows_cnt;
+#if LINUX_VERSION_IS_GEQ(5,3,10) ||	       \
+    LINUX_VERSION_IN_RANGE(4,19,83, 4,20,0) || \
+    LINUX_VERSION_IN_RANGE(4,14,153, 4,15,0) || \
+    LINUX_VERSION_IN_RANGE(4,9,200, 4,10,0) || \
+    LINUX_VERSION_IN_RANGE(4,4,200, 4,5,0)
+	siphash_key_t   perturbation;
+#else
 	u32 perturbation;
+#endif
 	u32 limit;
 	u32 memory_limit;
 	u32 memory_usage;
diff --git a/iwlwifi-stack-dev/include/net/fq_impl.h b/iwlwifi-stack-dev/include/net/fq_impl.h
index be7c0fa..b8beafb 100644
--- a/iwlwifi-stack-dev/include/net/fq_impl.h
+++ b/iwlwifi-stack-dev/include/net/fq_impl.h
@@ -118,7 +118,15 @@ static struct fq_flow *fq_flow_classify(struct fq *fq,
 
 	lockdep_assert_held(&fq->lock);
 
+#if LINUX_VERSION_IS_GEQ(5,3,10) || \
+    LINUX_VERSION_IN_RANGE(4,19,83, 4,20,0) || \
+    LINUX_VERSION_IN_RANGE(4,14,153, 4,15,0) || \
+    LINUX_VERSION_IN_RANGE(4,9,200, 4,10,0) || \
+    LINUX_VERSION_IN_RANGE(4,4,200, 4,5,0)
+	hash = skb_get_hash_perturb(skb, &fq->perturbation);
+#else
 	hash = skb_get_hash_perturb(skb, fq->perturbation);
+#endif
 	idx = reciprocal_scale(hash, fq->flows_cnt);
 	flow = &fq->flows[idx];
 
@@ -307,7 +315,7 @@ static int fq_init(struct fq *fq, int flows_cnt)
 	INIT_LIST_HEAD(&fq->backlogs);
 	spin_lock_init(&fq->lock);
 	fq->flows_cnt = max_t(u32, flows_cnt, 1);
-	fq->perturbation = prandom_u32();
+	get_random_bytes(&fq->perturbation, sizeof(fq->perturbation));
 	fq->quantum = 300;
 	fq->limit = 8192;
 	fq->memory_limit = 16 << 20; /* 16 MBytes */
diff --git a/iwlwifi-stack-dev/intc-scripts/chromeOS/copy-code.sh b/iwlwifi-stack-dev/intc-scripts/chromeOS/copy-code.sh
index efd2ea9..e469a5f 100755
--- a/iwlwifi-stack-dev/intc-scripts/chromeOS/copy-code.sh
+++ b/iwlwifi-stack-dev/intc-scripts/chromeOS/copy-code.sh
@@ -92,7 +92,7 @@ rm -f "$kernel_path/drivers/net/wireless$WIFIVERSION/iwl7000/mac80211/cfg.c_DIFF
 # remove wext includes
 find $kernel_path/drivers/net/wireless$WIFIVERSION/iwl7000/ -name '*.[ch]' |xargs sed -i 's/wext-compat\.h//;T;d'
 
-mkdir -p "$kernel_path/drivers/net/wireless$WIFIVERSION/iwl7000/hdrs/"{net,linux}
+mkdir -p "$kernel_path/drivers/net/wireless$WIFIVERSION/iwl7000/hdrs/"{net,linux,crypto}
 
 # copy these after spatch - otherwise it may modify it!
 cp -ar "$source_path/hdrs/" "$kernel_path/drivers/net/wireless$WIFIVERSION/iwl7000/"
@@ -120,6 +120,17 @@ sed -i 's/^mac80211-.*pm.o/\0\nmac80211-y += rhashtable.o/' "$kernel_path/driver
 cp "$driver_path/compat/lib-bucket_locks.c" "$kernel_path/drivers/net/wireless$WIFIVERSION/iwl7000/mac80211/bucket_locks.c"
 sed -i 's/^mac80211-.*pm.o/\0\nmac80211-y += bucket_locks.o/' "$kernel_path/drivers/net/wireless$WIFIVERSION/iwl7000/mac80211/Makefile"
 
+# handle arc4 - add our version thereof
+cp "$driver_path/compat/lib-crypto-arc4.c" "$kernel_path/drivers/net/wireless$WIFIVERSION/iwl7000/mac80211/arc4.c"
+cp "$driver_path/include/crypto/backport-arc4.h" "$kernel_path/drivers/net/wireless$WIFIVERSION/iwl7000/hdrs/crypto/arc4.h"
+sed -i 's/^mac80211-.*pm.o/\0\nmac80211-y += arc4.o/' "$kernel_path/drivers/net/wireless$WIFIVERSION/iwl7000/mac80211/Makefile"
+
+for fn in $(find $kernel_path/drivers/net/wireless$WIFIVERSION/iwl7000/ -name 'Makefile*') ; do
+	sed -i 's|\$(src)|\$(srctree)/\$(src)|' $fn
+	# remove implicit fallthrough warnings due to issues with clang
+	sed -i '/-Wimplicit-fallthrough/d' $fn
+done
+
 # Add the header file required to rename all the symbols - this
 # makes our driver compatible with installing and loading other
 # drivers that also use mac80211 (the native version, not ours)
diff --git a/iwlwifi-stack-dev/intc-scripts/chromeOS/hdrs/iwl-chrome.h b/iwlwifi-stack-dev/intc-scripts/chromeOS/hdrs/iwl-chrome.h
index 46ba34d..b2f6118 100644
--- a/iwlwifi-stack-dev/intc-scripts/chromeOS/hdrs/iwl-chrome.h
+++ b/iwlwifi-stack-dev/intc-scripts/chromeOS/hdrs/iwl-chrome.h
@@ -18,6 +18,12 @@
 
 #include <hdrs/mac80211-exp.h>
 
+#define LINUX_VERSION_IS_LESS(x1,x2,x3) (LINUX_VERSION_CODE < KERNEL_VERSION(x1,x2,x3))
+#define LINUX_VERSION_IS_GEQ(x1,x2,x3)  (LINUX_VERSION_CODE >= KERNEL_VERSION(x1,x2,x3))
+#define LINUX_VERSION_IN_RANGE(x1,x2,x3, y1,y2,y3) \
+        (LINUX_VERSION_IS_GEQ(x1,x2,x3) && LINUX_VERSION_IS_LESS(y1,y2,y3))
+#define LINUX_BACKPORT(sym) backport_ ## sym
+
 /* include rhashtable this way to get our copy if another exists */
 #include <linux/list_nulls.h>
 #ifndef NULLS_MARKER
@@ -36,12 +42,6 @@
 #include <linux/overflow.h>
 #include "net/fq.h"
 
-#define LINUX_VERSION_IS_LESS(x1,x2,x3) (LINUX_VERSION_CODE < KERNEL_VERSION(x1,x2,x3))
-#define LINUX_VERSION_IS_GEQ(x1,x2,x3)  (LINUX_VERSION_CODE >= KERNEL_VERSION(x1,x2,x3))
-#define LINUX_VERSION_IN_RANGE(x1,x2,x3, y1,y2,y3) \
-        (LINUX_VERSION_IS_GEQ(x1,x2,x3) && LINUX_VERSION_IS_LESS(y1,y2,y3))
-#define LINUX_BACKPORT(sym) backport_ ## sym
-
 #if LINUX_VERSION_IS_LESS(3,20,0)
 #define get_net_ns_by_fd LINUX_BACKPORT(get_net_ns_by_fd)
 static inline struct net *get_net_ns_by_fd(int fd)
@@ -228,6 +228,16 @@ static inline bool ether_addr_equal_unaligned(const u8 *addr1, const u8 *addr2)
 }
 #endif
 
+#if LINUX_VERSION_IS_GEQ(5,3,0)
+/*
+ * In v5.3, this function was renamed, so rename it here for v5.3+.
+ * When we merge v5.3 back from upstream, the opposite should be done
+ * (i.e. we will have _boottime_ and need to rename to _boot_ in <
+ * v5.3 instead).
+*/
+#define ktime_get_boot_ns ktime_get_boottime_ns
+#endif /* > 5.3.0 */
+
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3,17,0)
 #define kvfree __iwl7000_kvfree
 static inline void kvfree(const void *addr)
@@ -880,6 +890,13 @@ static inline void *kvzalloc(size_t size, gfp_t flags)
 
 #endif /* LINUX_VERSION_IS_LESS(4,12,0) */
 
+#if LINUX_VERSION_IS_LESS(4,14,0)
+static inline void *kvcalloc(size_t n, size_t size, gfp_t flags)
+{
+	return kvmalloc_array(n, size, flags | __GFP_ZERO);
+}
+#endif /* LINUX_VERSION_IS_LESS(4,14,0) */
+
 /* avoid conflicts with other headers */
 #ifdef is_signed_type
 #undef is_signed_type
@@ -990,4 +1007,9 @@ static inline int atomic_fetch_add_unless(atomic_t *v, int a, int u)
 }
 #endif
 #endif /* LINUX_VERSION_IS_LESS(4,19,0) */
+
+#if LINUX_VERSION_IS_LESS(5,4,0)
+#include <linux/pci-aspm.h>
+#endif
+
 #endif /* __IWL_CHROME */
diff --git a/iwlwifi-stack-dev/intc-scripts/chromeOS/hdrs/mac80211-bp.h b/iwlwifi-stack-dev/intc-scripts/chromeOS/hdrs/mac80211-bp.h
index 569ceac..061b455 100644
--- a/iwlwifi-stack-dev/intc-scripts/chromeOS/hdrs/mac80211-bp.h
+++ b/iwlwifi-stack-dev/intc-scripts/chromeOS/hdrs/mac80211-bp.h
@@ -2705,3 +2705,13 @@ static inline void cfg80211_bss_iter(struct wiphy *wiphy,
 	 */
 }
 #endif /* CFG80211_VERSION < KERNEL_VERSION(5,3,0) */
+
+#if CFG80211_VERSION < KERNEL_VERSION(9,9,9)
+#define NL80211_PREAMBLE_HE 4
+
+#define ftm_non_trigger_based(peer)	0
+#define ftm_trigger_based(peer)	0
+#else
+#define ftm_non_trigger_based(peer)	((peer)->ftm.non_trigger_based)
+#define ftm_trigger_based(peer)	((peer)->ftm.trigger_based)
+#endif
diff --git a/iwlwifi-stack-dev/intc-scripts/chromeOS/iwlwifi.patch b/iwlwifi-stack-dev/intc-scripts/chromeOS/iwlwifi.patch
index b569eb3..72b4ef5 100644
--- a/iwlwifi-stack-dev/intc-scripts/chromeOS/iwlwifi.patch
+++ b/iwlwifi-stack-dev/intc-scripts/chromeOS/iwlwifi.patch
@@ -265,6 +265,22 @@ index 9d5f7b853d52..49d44e8fedfe 100644
  	/*
  	 * No need to update right away, we'll get BSS_CHANGED_QOS
  	 * The exception is P2P_DEVICE interface which needs immediate update.
+@@ -4989,6 +4989,7 @@ static void iwl_mvm_set_sta_rate(u32 rate_n_flags, struct rate_info *rinfo)
+ 		if (rate_n_flags & RATE_MCS_SGI_MSK)
+ 			rinfo->flags |= RATE_INFO_FLAGS_SHORT_GI;
+ 	} else if (rate_n_flags & RATE_MCS_HE_MSK) {
++#if CFG80211_VERSION >= KERNEL_VERSION(4,19,0)
+ 		u32 gi_ltf = u32_get_bits(rate_n_flags,
+ 					  RATE_MCS_HE_GI_LTF_MSK);
+ 
+@@ -5033,6 +5034,7 @@ static void iwl_mvm_set_sta_rate(u32 rate_n_flags, struct rate_info *rinfo)
+ 
+ 		if (rate_n_flags & RATE_HE_DUAL_CARRIER_MODE)
+ 			rinfo->he_dcm = 1;
++#endif
+ 	} else {
+ 		switch (u32_get_bits(rate_n_flags, RATE_LEGACY_RATE_MSK)) {
+ 		case IWL_RATE_1M_PLCP:
 diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/scan.c b/drivers/net/wireless/intel/iwlwifi/mvm/scan.c
 index 4acee82e230d..98f4161725e5 100644
 --- a/drivers/net/wireless/intel/iwlwifi/mvm/scan.c
diff --git a/iwlwifi-stack-dev/intc-scripts/publishable-options b/iwlwifi-stack-dev/intc-scripts/publishable-options
index 17e86ff..5621b14 100644
--- a/iwlwifi-stack-dev/intc-scripts/publishable-options
+++ b/iwlwifi-stack-dev/intc-scripts/publishable-options
@@ -37,6 +37,7 @@ IWLMVM_TDLS_PEER_CACHE
 MAC80211_LATENCY_MEASUREMENTS
 IWLMVM_P2P_OPPPS_TEST_WA
 IWLMVM_VENDOR_CMDS
+IWLMVM_VENDOR_TCM_EVENTS
 IWLWIFI_THERMAL_DEBUGFS
 IWLWIFI_DISALLOW_OLDER_FW
 IWLWIFI_FORCE_OFDM_RATE
diff --git a/iwlwifi-stack-dev/local-symbols b/iwlwifi-stack-dev/local-symbols
index 39308e6..13ce985 100644
--- a/iwlwifi-stack-dev/local-symbols
+++ b/iwlwifi-stack-dev/local-symbols
@@ -24,6 +24,8 @@ BPAUTO_BUILD_SYSTEM_DATA_VERIFICATION=
 BPAUTO_PUBLIC_KEY=
 BPAUTO_ASN1_DECODER=
 BPAUTO_PKCS7=
+BPAUTO_CRYPTO_LIB_ARC4=
+BPAUTO_BUILD_CRYPTO_LIB_ARC4=
 CFG80211=
 NL80211_TESTMODE=
 CFG80211_DEVELOPER_WARNINGS=
@@ -104,6 +106,7 @@ IWLMVM_DISABLE_P2P_MIMO=
 IWLMVM_TDLS_PEER_CACHE=
 IWLMVM_P2P_OPPPS_TEST_WA=
 IWLMVM_VENDOR_CMDS=
+IWLMVM_VENDOR_TCM_EVENTS=
 IWLWIFI_DISALLOW_OLDER_FW=
 IWLWIFI_PCIE_FAKE_RXQS=
 IWLWIFI_NUM_STA_INTERFACES=
diff --git a/iwlwifi-stack-dev/net/mac80211/Kconfig b/iwlwifi-stack-dev/net/mac80211/Kconfig
index de16732..dd3d432 100644
--- a/iwlwifi-stack-dev/net/mac80211/Kconfig
+++ b/iwlwifi-stack-dev/net/mac80211/Kconfig
@@ -3,11 +3,7 @@ config MAC80211
 	depends on m
 	depends on CFG80211
 	depends on CRYPTO
-#if LINUX_VERSION_CODE > KERNEL_VERSION(5,2,21)
-	depends on CRYPTO_LIB_ARC4
-#elif
-	depends on CRYPTO_ARC4
-#endif
+	select BPAUTO_CRYPTO_LIB_ARC4
 	depends on CRYPTO_AES
 	depends on CRYPTO_CCM
 	depends on CRYPTO_GCM
diff --git a/iwlwifi-stack-dev/net/mac80211/cfg.c b/iwlwifi-stack-dev/net/mac80211/cfg.c
index 98b5107..60465f6 100644
--- a/iwlwifi-stack-dev/net/mac80211/cfg.c
+++ b/iwlwifi-stack-dev/net/mac80211/cfg.c
@@ -15,9 +15,7 @@
 #include <linux/slab.h>
 #include <net/net_namespace.h>
 #include <linux/rcupdate.h>
-#if LINUX_VERSION_CODE > KERNEL_VERSION(5,2,21)
 #include <linux/fips.h>
-#endif
 #include <linux/if_ether.h>
 #include <net/cfg80211.h>
 #include "ieee80211_i.h"
@@ -379,13 +377,8 @@ static int ieee80211_add_key(struct wiphy *wiphy, struct net_device *dev,
 	case WLAN_CIPHER_SUITE_WEP40:
 	case WLAN_CIPHER_SUITE_TKIP:
 	case WLAN_CIPHER_SUITE_WEP104:
-#if LINUX_VERSION_CODE > KERNEL_VERSION(5,2,21)
-		if (IS_ERR(fips_enabled)) 
-#elif
-		if (IS_ERR(local->wep_tx_tfm))
-#endif
+		if (WARN_ON_ONCE(fips_enabled))
 			return -EINVAL;
-		break;
 	case WLAN_CIPHER_SUITE_CCMP:
 	case WLAN_CIPHER_SUITE_CCMP_256:
 	case WLAN_CIPHER_SUITE_AES_CMAC:
diff --git a/iwlwifi-stack-dev/net/mac80211/ieee80211_i.h b/iwlwifi-stack-dev/net/mac80211/ieee80211_i.h
index 7b0cacc..41a5763 100644
--- a/iwlwifi-stack-dev/net/mac80211/ieee80211_i.h
+++ b/iwlwifi-stack-dev/net/mac80211/ieee80211_i.h
@@ -1345,13 +1345,9 @@ struct ieee80211_local {
 	atomic_t iff_allmultis;
 
 	struct rate_control_ref *rate_ctrl;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(5,2,21)
+
 	struct arc4_ctx wep_tx_ctx;
 	struct arc4_ctx wep_rx_ctx;
-#elif
-	struct crypto_cipher *wep_tx_tfm;
-	struct crypto_cipher *wep_rx_tfm;
-#endif
 	u32 wep_iv;
 
 	/* see iface.c */
diff --git a/iwlwifi-stack-dev/net/mac80211/key.h b/iwlwifi-stack-dev/net/mac80211/key.h
index 3a38819..2a5c910 100644
--- a/iwlwifi-stack-dev/net/mac80211/key.h
+++ b/iwlwifi-stack-dev/net/mac80211/key.h
@@ -15,9 +15,7 @@
 #include <linux/list.h>
 #include <linux/crypto.h>
 #include <linux/rcupdate.h>
-#if LINUX_VERSION_CODE > KERNEL_VERSION(5,2,21)
 #include <crypto/arc4.h>
-#endif
 #include <net/mac80211.h>
 
 #define NUM_DEFAULT_KEYS 4
diff --git a/iwlwifi-stack-dev/net/mac80211/main.c b/iwlwifi-stack-dev/net/mac80211/main.c
index ba85b4e..06fed8d 100644
--- a/iwlwifi-stack-dev/net/mac80211/main.c
+++ b/iwlwifi-stack-dev/net/mac80211/main.c
@@ -13,9 +13,7 @@
 
 #include <net/mac80211.h>
 #include <linux/module.h>
-#if LINUX_VERSION_CODE > KERNEL_VERSION(5,2,21)
 #include <linux/fips.h>
-#endif
 #include <linux/init.h>
 #include <linux/netdevice.h>
 #include <linux/types.h>
@@ -747,12 +745,7 @@ EXPORT_SYMBOL(ieee80211_alloc_hw_nm);
 
 static int ieee80211_init_cipher_suites(struct ieee80211_local *local)
 {
-#if LINUX_VERSION_CODE > KERNEL_VERSION(5,2,21)
 	bool have_wep = !fips_enabled; /* FIPS does not permit the use of RC4 */
-#elif
-	bool have_wep = !(IS_ERR(local->wep_tx_tfm) ||
-			  IS_ERR(local->wep_rx_tfm));
-#endif
 	bool have_mfp = ieee80211_hw_check(&local->hw, MFP_CAPABLE);
 	int n_suites = 0, r = 0, w = 0;
 	u32 *suites;
@@ -1313,12 +1306,8 @@ int ieee80211_register_hw(struct ieee80211_hw *hw)
 	ieee80211_remove_interfaces(local);
  fail_rate:
 	rtnl_unlock();
-	ieee80211_led_exit(local);
-
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(5,2,21)
-	ieee80211_wep_free(local);
-#endif
  fail_flows:
+	ieee80211_led_exit(local);
 	destroy_workqueue(local->workqueue);
  fail_workqueue:
 	wiphy_unregister(local->hw.wiphy);
@@ -1374,9 +1363,6 @@ void ieee80211_unregister_hw(struct ieee80211_hw *hw)
 
 	destroy_workqueue(local->workqueue);
 	wiphy_unregister(local->hw.wiphy);
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(5,2,21)
-	ieee80211_wep_free(local);
-#endif
 	ieee80211_led_exit(local);
 	kfree(local->int_scan_req);
 }
diff --git a/iwlwifi-stack-dev/net/mac80211/mlme.c b/iwlwifi-stack-dev/net/mac80211/mlme.c
index 310c5f0..ce252b8 100644
--- a/iwlwifi-stack-dev/net/mac80211/mlme.c
+++ b/iwlwifi-stack-dev/net/mac80211/mlme.c
@@ -15,9 +15,7 @@
  */
 
 #include <linux/delay.h>
-#if LINUX_VERSION_CODE > KERNEL_VERSION(5,2,21)
 #include <linux/fips.h>
-#endif
 #include <linux/if_ether.h>
 #include <linux/skbuff.h>
 #include <linux/if_arp.h>
@@ -5067,11 +5065,7 @@ int ieee80211_mgd_auth(struct ieee80211_sub_if_data *sdata,
 		auth_alg = WLAN_AUTH_OPEN;
 		break;
 	case NL80211_AUTHTYPE_SHARED_KEY:
-#if LINUX_VERSION_CODE > KERNEL_VERSION(5,2,21)
 		if (fips_enabled)
-#elif
-		if (IS_ERR(local->wep_tx_tfm))
-#endif
 			return -EOPNOTSUPP;
 		auth_alg = WLAN_AUTH_SHARED_KEY;
 		break;
diff --git a/iwlwifi-stack-dev/net/mac80211/tkip.c b/iwlwifi-stack-dev/net/mac80211/tkip.c
index da10d43..96b87fc 100644
--- a/iwlwifi-stack-dev/net/mac80211/tkip.c
+++ b/iwlwifi-stack-dev/net/mac80211/tkip.c
@@ -222,48 +222,28 @@ EXPORT_SYMBOL(ieee80211_get_tkip_p2k);
  * @payload_len is the length of payload (_not_ including IV/ICV length).
  * @ta is the transmitter addresses.
  */
-#if LINUX_VERSION_CODE > KERNEL_VERSION(5,2,21)
 int ieee80211_tkip_encrypt_data(struct arc4_ctx *ctx,
- 				struct ieee80211_key *key,
- 				struct sk_buff *skb,
- 				u8 *payload, size_t payload_len)
-#elif
-int ieee80211_tkip_encrypt_data(struct crypto_cipher *tfm,
 				struct ieee80211_key *key,
 				struct sk_buff *skb,
 				u8 *payload, size_t payload_len)
-#endif
 {
 	u8 rc4key[16];
 
 	ieee80211_get_tkip_p2k(&key->conf, skb, rc4key);
-#if LINUX_VERSION_CODE > KERNEL_VERSION(5,2,21)
+
 	return ieee80211_wep_encrypt_data(ctx, rc4key, 16,
- 					  payload, payload_len);
-#elif
-	return ieee80211_wep_encrypt_data(tfm, rc4key, 16,
 					  payload, payload_len);
-#endif
-
 }
 
 /* Decrypt packet payload with TKIP using @key. @pos is a pointer to the
  * beginning of the buffer containing IEEE 802.11 header payload, i.e.,
  * including IV, Ext. IV, real data, Michael MIC, ICV. @payload_len is the
  * length of payload, including IV, Ext. IV, MIC, ICV.  */
-#if LINUX_VERSION_CODE > KERNEL_VERSION(5,2,21)
 int ieee80211_tkip_decrypt_data(struct arc4_ctx *ctx,
- 				struct ieee80211_key *key,
- 				u8 *payload, size_t payload_len, u8 *ta,
- 				u8 *ra, int only_iv, int queue,
-				u32 *out_iv32, u16 *out_iv16)
-#elif
-int ieee80211_tkip_decrypt_data(struct crypto_cipher *tfm,
 				struct ieee80211_key *key,
 				u8 *payload, size_t payload_len, u8 *ta,
 				u8 *ra, int only_iv, int queue,
 				u32 *out_iv32, u16 *out_iv16)
-#endif
 {
 	u32 iv32;
 	u32 iv16;
@@ -316,11 +296,8 @@ int ieee80211_tkip_decrypt_data(struct crypto_cipher *tfm,
 	}
 
 	tkip_mixing_phase2(tk, &rx_ctx->ctx, iv16, rc4key);
-#if LINUX_VERSION_CODE > KERNEL_VERSION(5,2,21)
+
 	res = ieee80211_wep_decrypt_data(ctx, rc4key, 16, pos, payload_len - 12);
-#elif
-	res = ieee80211_wep_decrypt_data(tfm, rc4key, 16, pos, payload_len - 12);
-#endif
  done:
 	if (res == TKIP_DECRYPT_OK) {
 		/*
diff --git a/iwlwifi-stack-dev/net/mac80211/tkip.h b/iwlwifi-stack-dev/net/mac80211/tkip.h
index 2fa835b..7985830 100644
--- a/iwlwifi-stack-dev/net/mac80211/tkip.h
+++ b/iwlwifi-stack-dev/net/mac80211/tkip.h
@@ -12,35 +12,22 @@
 #include <linux/types.h>
 #include <linux/crypto.h>
 #include "key.h"
-#if LINUX_VERSION_CODE > KERNEL_VERSION(5,2,21)
+
 int ieee80211_tkip_encrypt_data(struct arc4_ctx *ctx,
- 				struct ieee80211_key *key,
- 				struct sk_buff *skb,
- 				u8 *payload, size_t payload_len);
-#elif
-int ieee80211_tkip_encrypt_data(struct crypto_cipher *tfm,
 				struct ieee80211_key *key,
 				struct sk_buff *skb,
 				u8 *payload, size_t payload_len);
-#endif
+
 enum {
 	TKIP_DECRYPT_OK = 0,
 	TKIP_DECRYPT_NO_EXT_IV = -1,
 	TKIP_DECRYPT_INVALID_KEYIDX = -2,
 	TKIP_DECRYPT_REPLAY = -3,
 };
-
-#if LINUX_VERSION_CODE > KERNEL_VERSION(5,2,21)
 int ieee80211_tkip_decrypt_data(struct arc4_ctx *ctx,
 				struct ieee80211_key *key,
 				u8 *payload, size_t payload_len, u8 *ta,
 				u8 *ra, int only_iv, int queue,
 				u32 *out_iv32, u16 *out_iv16);
-#elif
-int ieee80211_tkip_decrypt_data(struct crypto_cipher *tfm,
-				struct ieee80211_key *key,
-				u8 *payload, size_t payload_len, u8 *ta,
-				u8 *ra, int only_iv, int queue,
-				u32 *out_iv32, u16 *out_iv16);
-#endif
+
 #endif /* TKIP_H */
diff --git a/iwlwifi-stack-dev/net/mac80211/wep.c b/iwlwifi-stack-dev/net/mac80211/wep.c
index 79f5023..9f56737 100644
--- a/iwlwifi-stack-dev/net/mac80211/wep.c
+++ b/iwlwifi-stack-dev/net/mac80211/wep.c
@@ -30,33 +30,9 @@ int ieee80211_wep_init(struct ieee80211_local *local)
 	/* start WEP IV from a random value */
 	get_random_bytes(&local->wep_iv, IEEE80211_WEP_IV_LEN);
 
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(5,2,21) 
-	local->wep_tx_tfm = crypto_alloc_cipher("arc4", 0, 0);
-	if (IS_ERR(local->wep_tx_tfm)) {
-		local->wep_rx_tfm = ERR_PTR(-EINVAL);
-		return PTR_ERR(local->wep_tx_tfm);
-	}
-
-	local->wep_rx_tfm = crypto_alloc_cipher("arc4", 0, 0);
-	if (IS_ERR(local->wep_rx_tfm)) {
-		crypto_free_cipher(local->wep_tx_tfm);
-		local->wep_tx_tfm = ERR_PTR(-EINVAL);
-		return PTR_ERR(local->wep_rx_tfm);
-	}
-#endif
 	return 0;
 }
 
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(5,2,21) 
-void ieee80211_wep_free(struct ieee80211_local *local)
-{
-	if (!IS_ERR(local->wep_tx_tfm))
-		crypto_free_cipher(local->wep_tx_tfm);
-	if (!IS_ERR(local->wep_rx_tfm))
-		crypto_free_cipher(local->wep_rx_tfm);
-}
-#endif
-
 static inline bool ieee80211_wep_weak_iv(u32 iv, int keylen)
 {
 	/*
@@ -134,33 +110,18 @@ static void ieee80211_wep_remove_iv(struct ieee80211_local *local,
 /* Perform WEP encryption using given key. data buffer must have tailroom
  * for 4-byte ICV. data_len must not include this ICV. Note: this function
  * does _not_ add IV. data = RC4(data | CRC32(data)) */
-#if LINUX_VERSION_CODE > KERNEL_VERSION(5,2,21)
 int ieee80211_wep_encrypt_data(struct arc4_ctx *ctx, u8 *rc4key,
 			       size_t klen, u8 *data, size_t data_len)
-#elif
-int ieee80211_wep_encrypt_data(struct crypto_cipher *tfm, u8 *rc4key,
-			       size_t klen, u8 *data, size_t data_len)
-#endif
 {
 	__le32 icv;
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(5,2,21)
-	int i;
 
-	if (IS_ERR(tfm))
-		return -1;
-#endif
 	icv = cpu_to_le32(~crc32_le(~0, data, data_len));
 	put_unaligned(icv, (__le32 *)(data + data_len));
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(5,2,21) 
 	arc4_setkey(ctx, rc4key, klen);
 	arc4_crypt(ctx, data, data, data_len + IEEE80211_WEP_ICV_LEN);
 	memzero_explicit(ctx, sizeof(*ctx));
-#elif
-	crypto_cipher_setkey(tfm, rc4key, klen);
-	for (i = 0; i < data_len + IEEE80211_WEP_ICV_LEN; i++)
-		crypto_cipher_encrypt_one(tfm, data + i, data + i);
-#endif
+
 	return 0;
 }
 
@@ -197,47 +158,24 @@ int ieee80211_wep_encrypt(struct ieee80211_local *local,
 
 	/* Add room for ICV */
 	skb_put(skb, IEEE80211_WEP_ICV_LEN);
-#if LINUX_VERSION_CODE > KERNEL_VERSION(5,2,21)
 
 	return ieee80211_wep_encrypt_data(&local->wep_tx_ctx, rc4key, keylen + 3,
-
-					  iv + IEEE80211_WEP_IV_LEN, len);
-#elif
-
-	return ieee80211_wep_encrypt_data(local->wep_tx_tfm, rc4key, keylen + 3,
 					  iv + IEEE80211_WEP_IV_LEN, len);
-#endif
 }
 
 
 /* Perform WEP decryption using given key. data buffer includes encrypted
  * payload, including 4-byte ICV, but _not_ IV. data_len must not include ICV.
  * Return 0 on success and -1 on ICV mismatch. */
-#if LINUX_VERSION_CODE > KERNEL_VERSION(5,2,21)
 int ieee80211_wep_decrypt_data(struct arc4_ctx *ctx, u8 *rc4key,
- 			       size_t klen, u8 *data, size_t data_len)
-#elif
-int ieee80211_wep_decrypt_data(struct crypto_cipher *tfm, u8 *rc4key,
 			       size_t klen, u8 *data, size_t data_len)
-#endif
 {
 	__le32 crc;
 
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(5,2,21)
-	int i;
-
-	if (IS_ERR(tfm))
-		return -1;
-#endif
-#if LINUX_VERSION_CODE > KERNEL_VERSION(5,2,21) 
 	arc4_setkey(ctx, rc4key, klen);
 	arc4_crypt(ctx, data, data, data_len + IEEE80211_WEP_ICV_LEN);
 	memzero_explicit(ctx, sizeof(*ctx));
-#elif
-	crypto_cipher_setkey(tfm, rc4key, klen);
-	for (i = 0; i < data_len + IEEE80211_WEP_ICV_LEN; i++)
-		crypto_cipher_decrypt_one(tfm, data + i, data + i);
-#endif
+
 	crc = cpu_to_le32(~crc32_le(~0, data, data_len));
 	if (memcmp(&crc, data + data_len, IEEE80211_WEP_ICV_LEN) != 0)
 		/* ICV mismatch */
@@ -288,15 +226,10 @@ static int ieee80211_wep_decrypt(struct ieee80211_local *local,
 
 	/* Copy rest of the WEP key (the secret part) */
 	memcpy(rc4key + 3, key->conf.key, key->conf.keylen);
-#if LINUX_VERSION_CODE > KERNEL_VERSION(5,2,21) 
+
 	if (ieee80211_wep_decrypt_data(&local->wep_rx_ctx, rc4key, klen,
- 				       skb->data + hdrlen +
- 				       IEEE80211_WEP_IV_LEN, len))
-#elif
-	if (ieee80211_wep_decrypt_data(local->wep_rx_tfm, rc4key, klen,
 				       skb->data + hdrlen +
 				       IEEE80211_WEP_IV_LEN, len))
-#endif
 		ret = -1;
 
 	/* Trim ICV */
diff --git a/iwlwifi-stack-dev/net/mac80211/wep.h b/iwlwifi-stack-dev/net/mac80211/wep.h
index 17195a5..3644f4a 100644
--- a/iwlwifi-stack-dev/net/mac80211/wep.h
+++ b/iwlwifi-stack-dev/net/mac80211/wep.h
@@ -17,21 +17,13 @@
 #include "key.h"
 
 int ieee80211_wep_init(struct ieee80211_local *local);
-#if LINUX_VERSION_CODE > KERNEL_VERSION(5,2,21)
 int ieee80211_wep_encrypt_data(struct arc4_ctx *ctx, u8 *rc4key,
- 				size_t klen, u8 *data, size_t data_len);
-int ieee80211_wep_decrypt_data(struct arc4_ctx *ctx, u8 *rc4key,
- 			       size_t klen, u8 *data, size_t data_len);
-#elif
-void ieee80211_wep_free(struct ieee80211_local *local);
-int ieee80211_wep_encrypt_data(struct crypto_cipher *tfm, u8 *rc4key,
 				size_t klen, u8 *data, size_t data_len);
-int ieee80211_wep_decrypt_data(struct crypto_cipher *tfm, u8 *rc4key,
-			       size_t klen, u8 *data, size_t data_len);
-#endif
 int ieee80211_wep_encrypt(struct ieee80211_local *local,
 			  struct sk_buff *skb,
 			  const u8 *key, int keylen, int keyidx);
+int ieee80211_wep_decrypt_data(struct arc4_ctx *ctx, u8 *rc4key,
+			       size_t klen, u8 *data, size_t data_len);
 
 ieee80211_rx_result
 ieee80211_crypto_wep_decrypt(struct ieee80211_rx_data *rx);
diff --git a/iwlwifi-stack-dev/net/mac80211/wpa.c b/iwlwifi-stack-dev/net/mac80211/wpa.c
index 72a1c28..02e8ab7 100644
--- a/iwlwifi-stack-dev/net/mac80211/wpa.c
+++ b/iwlwifi-stack-dev/net/mac80211/wpa.c
@@ -242,13 +242,8 @@ static int tkip_encrypt_skb(struct ieee80211_tx_data *tx, struct sk_buff *skb)
 	/* Add room for ICV */
 	skb_put(skb, IEEE80211_TKIP_ICV_LEN);
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(5,2,21) 
 	return ieee80211_tkip_encrypt_data(&tx->local->wep_tx_ctx,
- 					   key, skb, pos, len);
-#elif
-	return ieee80211_tkip_encrypt_data(tx->local->wep_tx_tfm,
 					   key, skb, pos, len);
-#endif
 }
 
 
@@ -298,21 +293,12 @@ ieee80211_crypto_tkip_decrypt(struct ieee80211_rx_data *rx)
 	if (status->flag & RX_FLAG_DECRYPTED)
 		hwaccel = 1;
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(5,2,21) 
 	res = ieee80211_tkip_decrypt_data(&rx->local->wep_rx_ctx,
 					  key, skb->data + hdrlen,
 					  skb->len - hdrlen, rx->sta->sta.addr,
 					  hdr->addr1, hwaccel, rx->security_idx,
 					  &rx->tkip_iv32,
 					  &rx->tkip_iv16);
-#elif
-	res = ieee80211_tkip_decrypt_data(rx->local->wep_rx_tfm,
-					  key, skb->data + hdrlen,
-					  skb->len - hdrlen, rx->sta->sta.addr,
-					  hdr->addr1, hwaccel, rx->security_idx,
-					  &rx->tkip_iv32,
-					  &rx->tkip_iv16);
-#endif
 	if (res != TKIP_DECRYPT_OK)
 		return RX_DROP_UNUSABLE;
 
diff --git a/iwlwifi-stack-dev/net/wireless/Kconfig b/iwlwifi-stack-dev/net/wireless/Kconfig
index 6f08718..ab846a2 100644
--- a/iwlwifi-stack-dev/net/wireless/Kconfig
+++ b/iwlwifi-stack-dev/net/wireless/Kconfig
@@ -197,6 +197,7 @@ config LIB80211
 config LIB80211_CRYPT_WEP
 	tristate
 	depends on m
+	select BPAUTO_CRYPTO_LIB_ARC4
 
 config LIB80211_CRYPT_CCMP
 	tristate
@@ -205,6 +206,7 @@ config LIB80211_CRYPT_CCMP
 config LIB80211_CRYPT_TKIP
 	tristate
 	depends on m
+	select BPAUTO_CRYPTO_LIB_ARC4
 
 config LIB80211_DEBUG
 	bool "lib80211 debugging messages"
diff --git a/iwlwifi-stack-dev/net/wireless/lib80211_crypt_tkip.c b/iwlwifi-stack-dev/net/wireless/lib80211_crypt_tkip.c
index d2e7337..90eb3a3 100644
--- a/iwlwifi-stack-dev/net/wireless/lib80211_crypt_tkip.c
+++ b/iwlwifi-stack-dev/net/wireless/lib80211_crypt_tkip.c
@@ -13,6 +13,7 @@
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
 #include <linux/err.h>
+#include <linux/fips.h>
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/slab.h>
@@ -29,6 +30,7 @@
 #include <linux/ieee80211.h>
 #include <net/iw_handler.h>
 
+#include <crypto/arc4.h>
 #include <crypto/hash.h>
 #include <linux/crypto.h>
 #include <linux/crc32.h>
@@ -64,9 +66,9 @@ struct lib80211_tkip_data {
 
 	int key_idx;
 
-	struct crypto_cipher *rx_tfm_arc4;
+	struct arc4_ctx rx_ctx_arc4;
+	struct arc4_ctx tx_ctx_arc4;
 	struct crypto_shash *rx_tfm_michael;
-	struct crypto_cipher *tx_tfm_arc4;
 	struct crypto_shash *tx_tfm_michael;
 
 	/* scratch buffers for virt_to_page() (crypto API) */
@@ -93,30 +95,21 @@ static void *lib80211_tkip_init(int key_idx)
 {
 	struct lib80211_tkip_data *priv;
 
+	if (fips_enabled)
+		return NULL;
+
 	priv = kzalloc(sizeof(*priv), GFP_ATOMIC);
 	if (priv == NULL)
 		goto fail;
 
 	priv->key_idx = key_idx;
 
-	priv->tx_tfm_arc4 = crypto_alloc_cipher("arc4", 0, 0);
-	if (IS_ERR(priv->tx_tfm_arc4)) {
-		priv->tx_tfm_arc4 = NULL;
-		goto fail;
-	}
-
 	priv->tx_tfm_michael = crypto_alloc_shash("michael_mic", 0, 0);
 	if (IS_ERR(priv->tx_tfm_michael)) {
 		priv->tx_tfm_michael = NULL;
 		goto fail;
 	}
 
-	priv->rx_tfm_arc4 = crypto_alloc_cipher("arc4", 0, 0);
-	if (IS_ERR(priv->rx_tfm_arc4)) {
-		priv->rx_tfm_arc4 = NULL;
-		goto fail;
-	}
-
 	priv->rx_tfm_michael = crypto_alloc_shash("michael_mic", 0, 0);
 	if (IS_ERR(priv->rx_tfm_michael)) {
 		priv->rx_tfm_michael = NULL;
@@ -128,9 +121,7 @@ static void *lib80211_tkip_init(int key_idx)
       fail:
 	if (priv) {
 		crypto_free_shash(priv->tx_tfm_michael);
-		crypto_free_cipher(priv->tx_tfm_arc4);
 		crypto_free_shash(priv->rx_tfm_michael);
-		crypto_free_cipher(priv->rx_tfm_arc4);
 		kfree(priv);
 	}
 
@@ -142,11 +133,9 @@ static void lib80211_tkip_deinit(void *priv)
 	struct lib80211_tkip_data *_priv = priv;
 	if (_priv) {
 		crypto_free_shash(_priv->tx_tfm_michael);
-		crypto_free_cipher(_priv->tx_tfm_arc4);
 		crypto_free_shash(_priv->rx_tfm_michael);
-		crypto_free_cipher(_priv->rx_tfm_arc4);
 	}
-	kfree(priv);
+	kzfree(priv);
 }
 
 static inline u16 RotR1(u16 val)
@@ -345,7 +334,6 @@ static int lib80211_tkip_encrypt(struct sk_buff *skb, int hdr_len, void *priv)
 	int len;
 	u8 rc4key[16], *pos, *icv;
 	u32 crc;
-	int i;
 
 	if (tkey->flags & IEEE80211_CRYPTO_TKIP_COUNTERMEASURES) {
 		struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
@@ -370,9 +358,9 @@ static int lib80211_tkip_encrypt(struct sk_buff *skb, int hdr_len, void *priv)
 	icv[2] = crc >> 16;
 	icv[3] = crc >> 24;
 
-	crypto_cipher_setkey(tkey->tx_tfm_arc4, rc4key, 16);
-	for (i = 0; i < len + 4; i++)
-		crypto_cipher_encrypt_one(tkey->tx_tfm_arc4, pos + i, pos + i);
+	arc4_setkey(&tkey->tx_ctx_arc4, rc4key, 16);
+	arc4_crypt(&tkey->tx_ctx_arc4, pos, pos, len + 4);
+
 	return 0;
 }
 
@@ -400,7 +388,6 @@ static int lib80211_tkip_decrypt(struct sk_buff *skb, int hdr_len, void *priv)
 	u8 icv[4];
 	u32 crc;
 	int plen;
-	int i;
 
 	hdr = (struct ieee80211_hdr *)skb->data;
 
@@ -453,9 +440,8 @@ static int lib80211_tkip_decrypt(struct sk_buff *skb, int hdr_len, void *priv)
 
 	plen = skb->len - hdr_len - 12;
 
-	crypto_cipher_setkey(tkey->rx_tfm_arc4, rc4key, 16);
-	for (i = 0; i < plen + 4; i++)
-		crypto_cipher_decrypt_one(tkey->rx_tfm_arc4, pos + i, pos + i);
+	arc4_setkey(&tkey->rx_ctx_arc4, rc4key, 16);
+	arc4_crypt(&tkey->rx_ctx_arc4, pos, pos, plen + 4);
 
 	crc = ~crc32_le(~0, pos, plen);
 	icv[0] = crc;
@@ -641,17 +627,17 @@ static int lib80211_tkip_set_key(void *key, int len, u8 * seq, void *priv)
 	struct lib80211_tkip_data *tkey = priv;
 	int keyidx;
 	struct crypto_shash *tfm = tkey->tx_tfm_michael;
-	struct crypto_cipher *tfm2 = tkey->tx_tfm_arc4;
+	struct arc4_ctx *tfm2 = &tkey->tx_ctx_arc4;
 	struct crypto_shash *tfm3 = tkey->rx_tfm_michael;
-	struct crypto_cipher *tfm4 = tkey->rx_tfm_arc4;
+	struct arc4_ctx *tfm4 = &tkey->rx_ctx_arc4;
 
 	keyidx = tkey->key_idx;
 	memset(tkey, 0, sizeof(*tkey));
 	tkey->key_idx = keyidx;
 	tkey->tx_tfm_michael = tfm;
-	tkey->tx_tfm_arc4 = tfm2;
+	tkey->tx_ctx_arc4 = *tfm2;
 	tkey->rx_tfm_michael = tfm3;
-	tkey->rx_tfm_arc4 = tfm4;
+	tkey->rx_ctx_arc4 = *tfm4;
 	if (len == TKIP_KEY_LEN) {
 		memcpy(tkey->key, key, TKIP_KEY_LEN);
 		tkey->key_set = 1;
diff --git a/iwlwifi-stack-dev/net/wireless/lib80211_crypt_wep.c b/iwlwifi-stack-dev/net/wireless/lib80211_crypt_wep.c
index 20c1ad6..04e4d66 100644
--- a/iwlwifi-stack-dev/net/wireless/lib80211_crypt_wep.c
+++ b/iwlwifi-stack-dev/net/wireless/lib80211_crypt_wep.c
@@ -11,6 +11,7 @@
  */
 
 #include <linux/err.h>
+#include <linux/fips.h>
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/slab.h>
@@ -22,7 +23,7 @@
 
 #include <net/lib80211.h>
 
-#include <linux/crypto.h>
+#include <crypto/arc4.h>
 #include <linux/crc32.h>
 
 MODULE_AUTHOR("Jouni Malinen");
@@ -35,52 +36,31 @@ struct lib80211_wep_data {
 	u8 key[WEP_KEY_LEN + 1];
 	u8 key_len;
 	u8 key_idx;
-	struct crypto_cipher *tx_tfm;
-	struct crypto_cipher *rx_tfm;
+	struct arc4_ctx tx_ctx;
+	struct arc4_ctx rx_ctx;
 };
 
 static void *lib80211_wep_init(int keyidx)
 {
 	struct lib80211_wep_data *priv;
 
+	if (fips_enabled)
+		return NULL;
+
 	priv = kzalloc(sizeof(*priv), GFP_ATOMIC);
 	if (priv == NULL)
-		goto fail;
+		return NULL;
 	priv->key_idx = keyidx;
 
-	priv->tx_tfm = crypto_alloc_cipher("arc4", 0, 0);
-	if (IS_ERR(priv->tx_tfm)) {
-		priv->tx_tfm = NULL;
-		goto fail;
-	}
-
-	priv->rx_tfm = crypto_alloc_cipher("arc4", 0, 0);
-	if (IS_ERR(priv->rx_tfm)) {
-		priv->rx_tfm = NULL;
-		goto fail;
-	}
 	/* start WEP IV from a random value */
 	get_random_bytes(&priv->iv, 4);
 
 	return priv;
-
-      fail:
-	if (priv) {
-		crypto_free_cipher(priv->tx_tfm);
-		crypto_free_cipher(priv->rx_tfm);
-		kfree(priv);
-	}
-	return NULL;
 }
 
 static void lib80211_wep_deinit(void *priv)
 {
-	struct lib80211_wep_data *_priv = priv;
-	if (_priv) {
-		crypto_free_cipher(_priv->tx_tfm);
-		crypto_free_cipher(_priv->rx_tfm);
-	}
-	kfree(priv);
+	kzfree(priv);
 }
 
 /* Add WEP IV/key info to a frame that has at least 4 bytes of headroom */
@@ -132,7 +112,6 @@ static int lib80211_wep_encrypt(struct sk_buff *skb, int hdr_len, void *priv)
 	u32 crc, klen, len;
 	u8 *pos, *icv;
 	u8 key[WEP_KEY_LEN + 3];
-	int i;
 
 	/* other checks are in lib80211_wep_build_iv */
 	if (skb_tailroom(skb) < 4)
@@ -160,10 +139,8 @@ static int lib80211_wep_encrypt(struct sk_buff *skb, int hdr_len, void *priv)
 	icv[2] = crc >> 16;
 	icv[3] = crc >> 24;
 
-	crypto_cipher_setkey(wep->tx_tfm, key, klen);
-
-	for (i = 0; i < len + 4; i++)
-		crypto_cipher_encrypt_one(wep->tx_tfm, pos + i, pos + i);
+	arc4_setkey(&wep->tx_ctx, key, klen);
+	arc4_crypt(&wep->tx_ctx, pos, pos, len + 4);
 
 	return 0;
 }
@@ -181,7 +158,6 @@ static int lib80211_wep_decrypt(struct sk_buff *skb, int hdr_len, void *priv)
 	u32 crc, klen, plen;
 	u8 key[WEP_KEY_LEN + 3];
 	u8 keyidx, *pos, icv[4];
-	int i;
 
 	if (skb->len < hdr_len + 8)
 		return -1;
@@ -202,9 +178,8 @@ static int lib80211_wep_decrypt(struct sk_buff *skb, int hdr_len, void *priv)
 	/* Apply RC4 to data and compute CRC32 over decrypted data */
 	plen = skb->len - hdr_len - 8;
 
-	crypto_cipher_setkey(wep->rx_tfm, key, klen);
-	for (i = 0; i < plen + 4; i++)
-		crypto_cipher_decrypt_one(wep->rx_tfm, pos + i, pos + i);
+	arc4_setkey(&wep->rx_ctx, key, klen);
+	arc4_crypt(&wep->rx_ctx, pos, pos, plen + 4);
 
 	crc = ~crc32_le(~0, pos, plen);
 	icv[0] = crc;
diff --git a/iwlwifi-stack-dev/net/wireless/scan.c b/iwlwifi-stack-dev/net/wireless/scan.c
index e4107b4..a9a47bb 100644
--- a/iwlwifi-stack-dev/net/wireless/scan.c
+++ b/iwlwifi-stack-dev/net/wireless/scan.c
@@ -1690,8 +1690,7 @@ cfg80211_parse_mbssid_frame_data(struct wiphy *wiphy,
 static void
 cfg80211_update_notlisted_nontrans(struct wiphy *wiphy,
 				   struct cfg80211_bss *nontrans_bss,
-				   struct ieee80211_mgmt *mgmt, size_t len,
-				   gfp_t gfp)
+				   struct ieee80211_mgmt *mgmt, size_t len)
 {
 	u8 *ie, *new_ie, *pos;
 	const u8 *nontrans_ssid, *trans_ssid, *mbssid;
@@ -1702,6 +1701,8 @@ cfg80211_update_notlisted_nontrans(struct wiphy *wiphy,
 	const struct cfg80211_bss_ies *old;
 	u8 cpy_len;
 
+	lockdep_assert_held(&wiphy_to_rdev(wiphy)->bss_lock);
+
 	ie = mgmt->u.probe_resp.variable;
 
 	new_ie_len = ielen;
@@ -1710,26 +1711,30 @@ cfg80211_update_notlisted_nontrans(struct wiphy *wiphy,
 		return;
 	new_ie_len -= trans_ssid[1];
 	mbssid = cfg80211_find_ie(WLAN_EID_MULTIPLE_BSSID, ie, ielen);
-	if (!mbssid)
+	/*
+	 * It's not valid to have the MBSSID element before SSID
+	 * ignore if that happens - the code below assumes it is
+	 * after (while copying things inbetween).
+	 */
+	if (!mbssid || mbssid < trans_ssid)
 		return;
 	new_ie_len -= mbssid[1];
-	rcu_read_lock();
+
 	nontrans_ssid = ieee80211_bss_get_ie(nontrans_bss, WLAN_EID_SSID);
-	if (!nontrans_ssid) {
-		rcu_read_unlock();
+	if (!nontrans_ssid)
 		return;
-	}
+
 	new_ie_len += nontrans_ssid[1];
-	rcu_read_unlock();
 
 	/* generate new ie for nontrans BSS
 	 * 1. replace SSID with nontrans BSS' SSID
 	 * 2. skip MBSSID IE
 	 */
-	new_ie = kzalloc(new_ie_len, gfp);
+	new_ie = kzalloc(new_ie_len, GFP_ATOMIC);
 	if (!new_ie)
 		return;
-	new_ies = kzalloc(sizeof(*new_ies) + new_ie_len, gfp);
+
+	new_ies = kzalloc(sizeof(*new_ies) + new_ie_len, GFP_ATOMIC);
 	if (!new_ies)
 		goto out_free;
 
@@ -1887,6 +1892,8 @@ cfg80211_inform_bss_frame_data(struct wiphy *wiphy,
 	cfg80211_parse_mbssid_frame_data(wiphy, data, mgmt, len,
 					 &non_tx_data, gfp);
 
+	spin_lock_bh(&wiphy_to_rdev(wiphy)->bss_lock);
+
 	/* check if the res has other nontransmitting bss which is not
 	 * in MBSSID IE
 	 */
@@ -1901,8 +1908,9 @@ cfg80211_inform_bss_frame_data(struct wiphy *wiphy,
 		ies2 = rcu_access_pointer(tmp_bss->ies);
 		if (ies2->tsf < ies1->tsf)
 			cfg80211_update_notlisted_nontrans(wiphy, tmp_bss,
-							   mgmt, len, gfp);
+							   mgmt, len);
 	}
+	spin_unlock_bh(&wiphy_to_rdev(wiphy)->bss_lock);
 
 	return res;
 }
-- 
2.7.4

